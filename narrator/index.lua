local a,b,c,d=(function(e)local f={[{}]=true}local g local h={}local i local j={}g=function(k,l)if not h[k]then h[k]=l end end i=function(k)local l=j[k]if l then if l==f then return nil end else if not h[k]then if not e then local m=type(k)=='string'and'\"' .. k .. '\"'or tostring(k)error('Tried to require ' .. m .. ', but no such module has been registered')else return e(k)end end j[k]=f l=h[k](i,j,g,h)j[k]=l end return l end return i,j,g,h end)(require)c("__root",function(e,f,g,h)local i=e("narrator.libs.lume")local j=e("narrator.enums")local k=e("narrator.parser")local l=e("narrator.story")local m=package.config:sub(1,1)local function n(s)local t=s:gsub('.lua$','')local u=t:gsub('.ink$','')if u:match('%.')and not u:match(m)then u=u:gsub('%.',m)end return u end local function o(s)local t=n(s) .. '.ink'local u=io.open(t,'r')assert(u,'File doesn\'t exist: ' .. t)local v=u:read('*all')u:close()return v end local function p(s,t)local u=n(t) .. '.lua'local v=i.serialize(s)v=v:gsub('%[%d+%]=','')v=v:gsub('[\"[%w_]+\"]',function(x)return x:sub(3,#x-2)end)local w=io.open(u,'w')if w==nil then return false end w:write('return ' .. v)w:close()return true end local function q(s,t)if t.version.engine and t.version.engine~=j.engineVersion then assert('Version ' .. t.version.engine .. ' of book isn\'t equal to the version ' .. j.engineVersion .. ' of Narrator.')end s.tree._._=i.concat(t.tree._._,s.tree._._)t.tree._._=nil s.tree._=i.merge(t.tree._,s.tree._)t.tree._=nil s.tree=i.merge(s.tree or{},t.tree or{})s.constants=i.merge(s.constants or{},t.constants or{})s.lists=i.merge(s.lists or{},t.lists or{})s.variables=i.merge(s.variables or{},t.variables or{})return s end local r={}function r.parseFile(s,t)local u=t or{save=false}assert(k,"Can't parse anything without lpeg, sorry.")local v=o(s)local w=k.parse(v)for x,y in ipairs(w.inclusions)do local z=s:match('(.*' .. m .. ')')local A=z .. n(y) .. '.ink'local B=r.parseFile(A)q(w,B)end if u.save then p(w,s)end return w end function r.parseBook(s,t)local u=t or{}assert(k,"Can't parse anything without a parser.")local v=k.parse(s)for w,x in ipairs(u)do local y=k.parse(x)q(v,y)end return v end function r.initStory(s)local t=l(s)return t end function r.load(s)return r.initStory(r.parseBook((assert(love.filesystem.read(s),"File not found: " .. tostring(s)))))end return r end)c("narrator.story",function(e,f,g,h)local i=e("narrator.enums")local j=e("narrator.libs.lume")local k=e("narrator.libs.classic")local l=e("narrator.list.mt")local m=k:extend()function m:new(n)self.tree=n.tree self.constants=n.constants self.variables=j.clone(n.variables)self.lists=n.lists self.listMT=l self.listMT.lists=self.lists self.version=n.constants.version or 0 self.migrate=function(o,p,q)return o end self.functions=self:inkFunctions()self.observers={}self.globalTags=self:getTags()self.temp={}self.seeds={}self.choices={}self.paragraphs={}self.output={}self.visits={}self.currentPath=nil self.isOver=false end function m:begin()if#self.paragraphs>0 or#self.choices>0 then return end self:jumpTo('_')end function m:canContinue()return#self.paragraphs>0 end function m:continue(n)local o={}if not self:canContinue()then return o end local p=n or 0 p=p>0 and p or#self.paragraphs p=p>#self.paragraphs and#self.paragraphs or p for q=1,p do local r=self.paragraphs[q]r.text=r.text:gsub('^%s*(.-)%s*$','%1')table.insert(o,r)table.insert(self.output,r)end for q=1,p do table.remove(self.paragraphs,1)end return o end function m:canChoose()return self.choices~=nil and#self.choices>0 and not self:canContinue()end function m:getChoices()local n={}if self:canContinue()then return n end for o,p in ipairs(self.choices)do local q={text=p.title,tags=p.tags}table.insert(n,q)end return n end function m:choose(n)if self:canContinue()then return end local o=n>0 and n<=#self.choices assert(o,'Choice index ' .. n .. ' out of bounds 1-' .. #self.choices)local p=self.choices[n]assert(p,'Choice index ' .. n .. ' out of bounds 1-' .. #self.choices)self.paragraphs={}self.choices={}if p.text and#p.text>0 then local q={text=p.text,tags=p.tags}table.insert(self.paragraphs,q)end self:visit(p.path)if p.divert~=nil then self:jumpTo(p.divert)else self:readPath(p.path)end end function m:jumpTo(n)assert(n,'The pathString can\'t be nil')self.choices={}if n=='END'or n=='DONE'then self.isOver=true return end local o=self:pathFromString(n,self.currentPath)if o.label~=nil then o.chain=self:pathChainForLabel(o)end self:readPath(o)end function m:getVisits(n,o)local p=self:pathFromString(n,o)local q=self:getVisitsForPath(p)return q end function m:getTags(n)local o=self:pathFromString(n)local p=self:itemsFor(o.knot,o.stitch)local q={}for r,s in ipairs(p)do if type(s)=='table'and j.count(s)>1 or s.tags==nil then break end local t=type(s.tags)=='string'and{s.tags}or s.tags q=j.concat(q,t)end return q end function m:saveState()local n={version=self.version,temp=self.temp,seeds=self.seeds,variables=self.variables,visits=self.visits,path=self.currentPath,paragraphs=self.paragraphs,choices=self.choices,output=self.output}return n end function m:loadState(n)if self.version~=n.version then n=self.migrate(n,n.version,self.version)end self.temp=n.temp self.seeds=n.seeds self.variables=n.variables self.visits=n.visits self.currentPath=n.path self.paragraphs=n.paragraphs self.choices=n.choices self.output=n.output end function m:observe(n,o)self.observers[n]=o end function m:bind(n,o)self.functions[n]=o end function m:pathChainForLabel(n)local o=n.label local p=self:itemsFor(n.knot,n.stitch)local function q(s)for t,u in ipairs(s)do if u.label==o then return{t}elseif u.node~=nil then local v=q(u.node)if v~=nil then table.insert(v,0,t)return v end elseif u.success~=nil then if type(u.success)=='table'then local v=u.success[1]~=nil and u.success[1][1]~=nil local w=v and u.success or{u.success}for x,y in ipairs(w)do local z=q(y)if z~=nil then table.insert(z,0,'t' .. x)table.insert(z,0,t)return z end end end if type(u.failure)=='table'then local v=q(u.failure)if v~=nil then table.insert(v,0,'f')table.insert(v,0,t)return v end end end end return nil end local r=q(p)assert(r,'Label \'' .. n.label .. '\' not found')return r end function m:readPath(n)assert(n,'The reading path can\'t be nil')if self.isOver then return end if not n.label then self:visit(n)end local o=self:itemsFor(n.knot,n.stitch)self:readItems(o,n)end function m:itemsFor(n,o)local p=self.tree local q=n==nil and p._ or p[n]assert(q or j.isarray(p),'The knot \'' .. (n or'_') .. '\' not found')local r=o==nil and q._ or q[o]assert(r or j.isarray(q),'The stitch \'' .. (n or'_') .. '.' .. (o or'_') .. '\' not found')return r or q or p end function m:readItems(n,o,p,q)assert(n,'Items can\'t be nil')assert(o,'Path can\'t be nil')local r=o.chain or{}local s=p or 0 local t=r[s+1]local u=q or i.readMode.text local v=function(w,x)local y=j.slice(r,1,s)for A,B in ipairs(w)do y[s+A]=B end local z=j.clone(o)z.chain=y if x then z.label=x .. table.concat(y,'.')end return z end for w=t or 1,#n do local x=n[w]local y=false local z=i.item.text if type(x)=='table'then if x.choice~=nil then z=i.item.choice elseif x.success~=nil then z=i.item.condition elseif x.var~=nil then z=i.item.variable elseif x.alts~=nil then z=i.item.alts end end if w==t then if z==i.item.choice and x.node~=nil then u=i.readMode.gathers u=self:readItems(x.node,o,s+1)or u elseif z==i.item.condition then local A=r[s+2]local B=A:sub(1,1)=='t'local C if B then local D=tonumber(A:sub(2,2))or 0 C=D>0 and x.success[D]or x.success else C=x.failure end u=self:readItems(C,o,s+2,u)or u end if z==i.item.condition or z==i.item.choice then u=u~=i.readMode.quit and i.readMode.gathers or u y=true end end if u==i.readMode.choices and z~=i.item.choice then u=i.readMode.quit y=true elseif u==i.readMode.gathers and z==i.item.choice then y=true end if y then elseif z==i.item.text then u=i.readMode.text local A=type(x)=='string'and{text=x}or x u=self:readText(A)or u elseif z==i.item.alts then u=i.readMode.text local A=v({w},'~')u=self:readAlts(x,A,s+1,u)or u elseif z==i.item.choice and self:checkCondition(x.condition)then u=i.readMode.choices local A=v({w},'>')A.label=x.label or A.label u=self:readChoice(x,A)or u if w==#n and type(r[#r])=='number'then u=i.readMode.quit end elseif z==i.item.condition then local A,B if type(x.condition)=='string'then local C=self:checkCondition(x.condition)A=C and x.success or(x.failure or{})B=C and't'or'f'elseif type(x.condition)=='table'then local C=self:checkSwitch(x.condition)A=C>0 and x.success[C]or(x.failure or{})B=C>0 and('t' .. C)or'f'end if type(A)=='string'then u=i.readMode.text u=self:readText({text=A})or u elseif type(A)=='table'then local C=v({w,B})u=self:readItems(A,C,s+2,u)or u end elseif z==i.item.variable then self:assignValueTo(x.var,x.value,x.temp)end if x.label~=nil and z~=i.item.choice and not y then local A=j.clone(o)A.label=x.label self:visit(A)end if u==i.readMode.quit then break end end if s==0 then for w=#self.paragraphs,1,-1 do local x=self.paragraphs[w]if(not x.text or#x.text==0)and(not x.tags or#x.tags==0)then table.remove(self.paragraphs,w)else x.text=x.text:match('(.-)%s*<>$')or x.text end end end return u end function m:readText(n)local o=n.text local p=type(n.tags)=='string'and{n.tags}or n.tags if o~=nil or p~=nil then local q={text=o or'<>',tags=p}local r=#self.paragraphs>0 and self.paragraphs[#self.paragraphs].text:sub(-2)=='<>'local s=o~=nil and o:sub(1,2)=='<>'q.text=self:replaceExpressions(q.text)q.text=q.text:gsub('%s+',' ')if r then local t=self.paragraphs[#self.paragraphs]t.text=t.text:sub(1,#t.text-2)self.paragraphs[#self.paragraphs]=t end if s then q.text=q.text:sub(3)end if r or(s and#self.paragraphs>0)then local t=self.paragraphs[#self.paragraphs]t.text=(t.text .. q.text):gsub('%s+',' ')t.tags=j.concat(t.tags,q.tags)t.tags=#t.tags>0 and t.tags or nil self.paragraphs[#self.paragraphs]=t else table.insert(self.paragraphs,#self.paragraphs+1,q)end end if n.divert~=nil then self:jumpTo(n.divert)return i.readMode.quit end end function m:readAlts(n,o,p,q)assert(n.alts,'Alternatives can\'t be nil')local r=j.clone(n.alts)local s=n.sequence or i.sequence.stopping if type(s)=='string'then s=i.sequence[n.sequence]or s end self:visit(o)local t=self:getVisitsForPath(o)local u=0 if n.shuffle then local x=(o.knot or'_') .. '.' .. (o.stitch or'_') .. ':' .. o.label local y=t%#r==1 and(self.debugSeed or os.time()*1000)or self.seeds[x]self.seeds[x]=y for z,A in ipairs(r)do math.randomseed(y+z)local B=z<#r and math.random(z,#r)or z r[z]=r[B]r[B]=A end end if s==i.sequence.cycle then u=t%#r u=u>0 and u or#r elseif s==i.sequence.stopping then u=t<#r and t or#r elseif s==i.sequence.once then u=t end local v=u<=#r and r[u]or{}local w=type(v)=='string'and{v}or v return self:readItems(w,o,p,q)end function m:readChoice(n,o)local p=n.choice==0 if p then if#self.choices==0 then if n.divert~=nil then self:jumpTo(n.divert)else self:readPath(o)end end return i.readMode.quit end local q=self:replaceExpressions(n.choice)q=q:match('(.-)%s*<>$')or q local r={title=q,text=n.text~=nil and self:replaceExpressions(n.text)or q,divert=n.divert,tags=n.tags,path=o}if n.sticky or self:getVisitsForPath(o)==0 then table.insert(self.choices,#self.choices+1,r)end end function m:replaceExpressions(n)return n:gsub('%b##',function(o)if#o==2 then return'#'else local p=self:doExpression(o:sub(2,#o-1))if type(p)=='table'then p=self.listMT.__tostring(p)elseif type(p)=='boolean'then p=p and 1 or 0 elseif type(p)=='number'then p=tostring(p)if p:sub(-2)=='.0'then p=p:sub(1,-3)end elseif p==nil then p=''end return p end end)end function m:checkSwitch(n)for o,p in ipairs(n)do if self:checkCondition(p)then return o end end return 0 end function m:checkCondition(n)if n==nil then return true end local o=self:doExpression(n)if type(o)=='table'and not next(o)then o=nil end return o~=nil and o~=false end function m:doExpression(n)assert(type(n)=='string','Expression must be a string')local o=''local p={}n=n:gsub('!=','~=')n=n:gsub('%s*||%s*',' or ')n=n:gsub('%s*%&%&%s*',' and ')n=n:gsub('%s+has%s+',' ? ')n=n:gsub('%s+hasnt%s+',' !? ')n=n:gsub('[%a_][%w_]*%b()',function(r)local s=r:match('([%a_][%w_]*)%(')local t=r:match('[%a_][%w_]*%((.+)%)')local u=t~=nil and j.map(j.split(t,','),j.trim)or nil for w,x in ipairs(u or{})do u[w]=self:doExpression(x)end local v=self.functions[s]if v~=nil then local w=v((table.unpack or unpack)(u or{}))if type(w)=='table'then p[#p+1]=w return'__list' .. #p else return j.serialize(w)end elseif self.lists[s]~=nil then local w=u and u[1]or 0 local x=self.lists[s][w]local y=x and{[s]={[x]=true}}or{}p[#p+1]=y return'__list' .. #p end return'nil'end)n=n:gsub('%(([%s%w%.,_]*)%)',function(r)local s=self:makeListFor(r)if s~=nil then p[#p+1]=s return'__list' .. #p else return'nil'end end)local q={}n=n:gsub('%b\"\"',function(r)table.insert(q,r)return'#' .. #q .. '#'end)n=n:gsub('[%a_][%w_%.]*',function(r)local s={'and','or','true','false','nil','not'}if j.find(s,r)or r:match('__list%d*')then return r else local t=self:getValueFor(r)if type(t)=='table'then p[#p+1]=t return'__list' .. #p else return j.serialize(t)end end end)n=n:gsub('[%a_#][%w_%.#]*[%s]*[%?!]+[%s]*[%a_#][%w_%.#]*',function(r)local s,t,u=r:match('([%a_#][%w_%.#]*)[%s]*([%!?]+)[%s]*([%a_#][%w_%.#]*)')if s:match('__list%d*')then return s .. ' % ' .. u .. (t=='?'and' == true'or' == false')else return'string.match(' .. s .. ', ' .. u .. ')' .. (t=='?'and' ~= nil'or' == nil')end end)n=n:gsub('%b##',function(r)local s=tonumber(r:sub(2,-2))return q[s or 0]end)if#p>0 then o=o .. 'local mt = require(\'narrator.list.mt\')\n'o=o .. 'mt.lists = ' .. j.serialize(self.lists) .. '\n\n'for r,s in pairs(p)do local t='__list' .. r o=o .. 'local ' .. t .. ' = ' .. j.serialize(s) .. '\n'o=o .. 'setmetatable(' .. t .. ', mt)\n\n'end end o=o .. 'return ' .. n return j.dostring(o)end function m:assignValueTo(n,o,p)if self.constants[n]~=nil then return end local q=self:doExpression(o)if#n==0 then return end local r=(p or self.temp[n]~=nil)and self.temp or self.variables if r[n]==q then return end r[n]=q local s=self.observers[n]if s~=nil then s(q)end end function m:getValueFor(n)local o=self.temp[n]if o==nil then o=self.variables[n]end if o==nil then o=self.constants[n]end if o==nil then o=self:makeListFor(n)end if o==nil then local p=self:getVisits(n,self.currentPath)o=p>0 and p or nil end return o end function m:makeListFor(n)local o={}if not n:find('%S')then return o end local p=j.array(n:gmatch('[%w_%.]+'))for q,r in ipairs(p)do local s,t=self:getListNameFor(r)if s~=nil and t~=nil then o[s]=o[s]or{}o[s][t]=true end end return next(o)~=nil and o or nil end function m:getListNameFor(n)local o,p=n:match('([%w_]+)%.([%w_]+)')p=p or n if o==nil then for r,s in pairs(self.lists)do for t,u in ipairs(s)do if u==p then o=r break end end end end local q=o==nil or self.lists[o]==nil if q then return nil end return o,p end function m:visit(n)local o=self.currentPath==nil or n.knot~=self.currentPath.knot or n.stitch~=self.currentPath.stitch if o then if self.currentPath==nil or n.knot~=self.currentPath.knot then local s=n.knot or'_'local t=self.visits[s]or{_root=0}t._root=t._root+1 self.visits[s]=t end local p,q=n.knot or'_',n.stitch or'_'local r=self.visits[p][q]or{_root=0}r._root=r._root+1 self.visits[p][q]=r end if n.label~=nil then local p,q,r=n.knot or'_',n.stitch or'_',n.label self.visits[p]=self.visits[p]or{_root=1,_={_root=1}}self.visits[p][q]=self.visits[p][q]or{_root=1}local s=self.visits[p][q][r]or 0 s=s+1 self.visits[p][q][n.label]=s end self.currentPath=j.clone(n)self.currentPath.label=nil self.temp=o and{}or self.temp end function m:getVisitsForPath(n)if n==nil then return 0 end local o,p,q=n.knot or'_',n.stitch,n.label if p==nil and q~=nil then p='_'end local r=self.visits[o]if r==nil then return 0 elseif p==nil then return r._root or 0 end local s=r[p]if s==nil then return 0 elseif q==nil then return s._root or 0 end local t=s[q]return t or 0 end function m:pathFromString(n,o)local p=n or''local q=o and o.knot local r=o and o.stitch q=q or'_'r=r or'_'local s,t,u=p:match('([%w_]+)%.([%w_]+)%.([%w_]+)')if not s then s,t=p:match('([%w_]+)%.([%w_]+)')end if not s then s=#p>0 and p or nil end local v={}if not s then return v end if u then v.knot=s v.stitch=t v.label=u return v end if t then if self.tree[s]and self.tree[s][t]then v.knot=s v.stitch=t return v end if self.tree[q][s]then v.knot=q v.stitch=s v.label=t return v end if self.tree[s]then v.knot=s v.stitch='_'v.label=t return v end if self.tree._[s]then v.knot='_'v.stitch=s v.label=t return v end end if s then if self.tree[q][s]then v.knot=q v.stitch=s return v elseif self.tree[s]then v.knot=s return v else v.knot=q v.stitch=r v.label=s end end return v end function m:inkFunctions()return{CHOICE_COUNT=function()return#self.choices end,SEED_RANDOM=function(n)self.debugSeed=n end,POW=function(n,o)return math.pow(n,o)end,RANDOM=function(n,o)math.randomseed(self.debugSeed or os.clock()*1000)return math.random(n,o)end,INT=function(n)return math.floor(n)end,FLOOR=function(n)return math.floor(n)end,FLOAT=function(n)return n end,LIST_VALUE=function(n)return self.listMT.firstRawValueOf(n)end,LIST_COUNT=function(n)return self.listMT.__len(n)end,LIST_MIN=function(n)return self.listMT.minValueOf(n)end,LIST_MAX=function(n)return self.listMT.maxValueOf(n)end,LIST_RANDOM=function(n)math.randomseed(self.debugSeed or os.clock()*1000)return self.listMT.randomValueOf(n)end,LIST_ALL=function(n)return self.listMT.posibleValuesOf(n)end,LIST_RANGE=function(n,o,p)return self.listMT.rangeOf(n,o,p)end,LIST_INVERT=function(n)return self.listMT.invert(n)end}end return m end)c("narrator.list.mt",function(e,f,g,h)local i=e("narrator.libs.lume")local j={lists={}}function j.__tostring(k)local l={}local m={}for o,p in pairs(k)do table.insert(m,o)end table.sort(m)for o=1,#m do local p=m[o]local q=k[p]for r=1,#j.lists[p]do l[r]=l[r]or{}local s=j.lists[p][r]if q[s]==true then table.insert(l[r],1,s)end end end local n={}for o,p in ipairs(l)do for q,r in ipairs(p)do table.insert(n,r)end end return table.concat(n,', ')end function j.__add(k,l)if type(l)=='table'then return j.__addList(k,l)elseif type(l)=='number'then return j.__shiftByNumber(k,l)else error('Attempt to sum the list with ' .. type(l))end end function j.__sub(k,l)if type(l)=='table'then return j.__subList(k,l)elseif type(l)=='number'then return j.__shiftByNumber(k,-l)else error('Attempt to sub the list with ' .. type(l))end end function j.__mod(k,l)if type(l)~='table'then error('Attempt to check content of the list for ' .. type(l))end for m,n in pairs(l)do if k[m]==nil then return false end for o,p in pairs(n)do if(k[m][o]or false)~=p then return false end end end return true end function j.__pow(k,l)if type(l)~='table'then error('Attempt to interselect the list with ' .. type(l))end local m={}for n,o in pairs(k)do for p,q in pairs(o)do local r=k[n][p]local s=(l[n]or{})[p]if r==true and s==true then m[n]=m[n]or{}m[n][p]=true end end end setmetatable(m,j)return m end function j.__len(k)local l=0 for m,n in pairs(k)do for o,p in pairs(n)do if p==true then l=l+1 end end end return l end function j.__eq(k,l)if type(l)~='table'then error('Attempt to compare the list with ' .. type(l))end local function m(p)local q=0 for r,s in pairs(p)do q=q+1 end return q end local n=m(k)local o=m(l)if n~=o then return false end for p,q in pairs(k)do local r=l[p]if r==nil then return false end local s=m(q)local t=m(r)if s~=t then return false end end return j.__mod(k,l)end function j.__lt(k,l)if type(l)~='table'then error('Attempt to compare the list with ' .. type(l))end local m=j.minValueOf(k,true)local n=j.maxValueOf(l,true)return m<n end function j.__le(k,l)if type(l)~='table'then error('Attempt to compare the list with ' .. type(l))end local m=j.minValueOf(l,true)local n=j.minValueOf(k,true)local o=j.maxValueOf(l,true)local p=j.maxValueOf(k,true)return m>=n and o>=p end function j.__addList(k,l)local m=i.clone(k)for n,o in pairs(l)do m[n]=m[n]or{}for p,q in pairs(o)do m[n][p]=q end end return m end function j.__subList(k,l)local m=i.clone(k)for n,o in pairs(l)do if k[n]~=nil then for p,q in pairs(o)do k[n][p]=nil end end end return j.removeEmptiesInList(m)end function j.__shiftByNumber(k,l)local m={}for n,o in pairs(k)do m[n]={}for p,q in ipairs(j.lists[n])do if o[q]==true then local r=j.lists[n][p+l]if r~=nil then m[n][r]=true end end end end return j.removeEmptiesInList(m)end function j.removeEmptiesInList(k)local l=i.clone(k)for m,n in pairs(k)do if next(n)==nil then l[m]=nil end end return l end function j.minValueOf(k,l)local m=0 local n={}local o={}for p,q in pairs(k)do table.insert(o,p)end table.sort(o)for p=1,#o do local q=o[p]local r=k[q]for s,t in pairs(r)do if t==true then local u=i.find(j.lists[q],s)if u and u<m or m==0 then m=u n={[q]={[s]=true}}end end end end return l and m or n end function j.maxValueOf(k,l)local m=0 local n={}local o={}for p,q in pairs(k)do table.insert(o,p)end table.sort(o)for p=1,#o do local q=o[p]local r=k[q]for s,t in pairs(r)do if t==true then local u=i.find(j.lists[q],s)if u and u>m or m==0 then m=u n={[q]={[s]=true}}end end end end return l and m or n end function j.randomValueOf(k)local l={}local m={}for o,p in pairs(k)do table.insert(m,o)end table.sort(m)for o=1,#m do local p=m[o]local q=k[p]local r={}for s,t in pairs(q)do table.insert(r,s)end table.sort(r)for s=1,#r do local t=r[s]local u=q[t]if u==true then local v={[p]={[t]=true}}table.insert(l,v)end end end local n=math.random(1,#l)return l[n]end function j.firstRawValueOf(k)local l=0 for m,n in pairs(k)do for o,p in pairs(n)do if p==true then local q=i.find(j.lists[m],o)if q then l=q break end end end end return l end function j.posibleValuesOf(k)local l={}for m,n in pairs(k)do local o={}for p,q in ipairs(j.lists[m])do o[q]=true end l[m]=o end return l end function j.rangeOf(k,l,m)if type(l)~='table'and type(l)~='number'then error('Attempt to get a range with incorrect min value of type ' .. type(l))end if type(m)~='table'and type(m)~='number'then error('Attempt to get a range with incorrect max value of type ' .. type(m))end local n={}local o=j.posibleValuesOf(k)local p=type(l)=='number'and l or j.firstRawValueOf(l)local q=type(m)=='number'and m or j.firstRawValueOf(m)for r,s in pairs(o)do for t,u in pairs(s)do local v=i.find(j.lists[r],t)if v and v>=p and v<=q and k[r][t]==true then n[r]=n[r]or{}n[r][t]=true end end end return n end function j.invert(k)local l=j.posibleValuesOf(k)for m,n in pairs(k)do for o,p in pairs(n)do if p==true then l[m][o]=nil end end end return l end return j end)c("narrator.libs.lume",function(e,f,g,h)local i={_version="2.3.0"}local j,k=pairs,ipairs local l,m,n=type,assert,unpack or table.unpack local o,p=tostring,tonumber local q=math.floor local r=math.ceil local s=math.atan2 or math.atan local t=math.sqrt local u=math.abs local v=function()end local w=function(J)return J end local x=function(J)return J:gsub("[%(%)%.%%%+%-%*%?%[%]%^%$]","%%%1")end local y=function(J,K)return K<0 and(J+K+1)or K end local z=function(J)if l(J)=="function"then return true end local K=getmetatable(J)return K and K.__call~=nil end local A=function(J)if i.isarray(J)then return k elseif l(J)=="table"then return j end error("expected table",3)end local B=function(J)if J==nil then return w end if z(J)then return J end if l(J)=="table"then return function(K)for L,M in j(J)do if K[L]~=M then return false end end return true end end return function(K)return K[J]end end function i.clamp(J,K,L)return J<K and K or(J>L and L or J)end function i.round(J,K)if K then return i.round(J/K)*K end return J>=0 and q(J+.5)or r(J-.5)end function i.sign(J)return J<0 and-1 or 1 end function i.lerp(J,K,L)return J+(K-J)*i.clamp(L,0,1)end function i.smooth(J,K,L)local M=i.clamp(L,0,1)local N=M*M*(3-2*M)return J+(K-J)*N end function i.pingpong(J)return 1-u(1-J%2)end function i.distance(J,K,L,M,N)local O=J-L local P=K-M local Q=O*O+P*P return N and Q or t(Q)end function i.angle(J,K,L,M)return s(M-K,L-J)end function i.vector(J,K)return math.cos(J)*K,math.sin(J)*K end function i.random(J,K)if not J then J,K=0,1 end if not K then K=0 end return J+math.random()*(K-J)end function i.randomchoice(J)return J[math.random(#J)]end function i.weightedchoice(J)local K=0 for M,N in j(J)do m(N>=0,"weight value less than zero")K=K+N end m(K~=0,"all weights are zero")local L=i.random(K)for M,N in j(J)do if L<N then return M end L=L-N end end function i.isarray(J)return l(J)=="table"and J[1]~=nil end function i.push(J,...)local K=select("#",...)for L=1,K do J[#J+1]=select(L,...)end return...end function i.remove(J,K)local L=A(J)for M,N in L(J)do if N==K then if i.isarray(J)then table.remove(J,M)break else J[M]=nil break end end end return K end function i.clear(J)local K=A(J)for L in K(J)do J[L]=nil end return J end function i.extend(J,...)for K=1,select("#",...)do local L=select(K,...)if L then for M,N in j(L)do J[M]=N end end end return J end function i.shuffle(J)local K={}for L=1,#J do local M=math.random(L)if M~=L then K[L]=K[M]end K[M]=J[L]end return K end function i.sort(J,K)local L=i.clone(J)if K then if l(K)=="string"then table.sort(L,function(M,N)return M[K]<N[K]end)else table.sort(L,K)end else table.sort(L)end return L end function i.array(...)local J={}for K in...do J[#J+1]=K end return J end function i.each(J,K,...)local L=A(J)if l(K)=="string"then for M,N in L(J)do N[K](N,...)end else for M,N in L(J)do K(N,...)end end return J end function i.map(J,K)K=B(K)local L=A(J)local M={}for N,O in L(J)do M[N]=K(O)end return M end function i.all(J,K)K=B(K)local L=A(J)for M,N in L(J)do if not K(N)then return false end end return true end function i.any(J,K)K=B(K)local L=A(J)for M,N in L(J)do if K(N)then return true end end return false end function i.reduce(J,K,L)local M=L~=nil local N=L local O=A(J)for P,Q in O(J)do if M then N=K(N,Q)else N=Q M=true end end m(M,"reduce of an empty table with no first value")return N end function i.unique(J)local K={}for L in j(i.invert(J))do K[#K+1]=L end return K end function i.filter(J,K,L)K=B(K)local M=A(J)local N={}if L then for O,P in M(J)do if K(P)then N[O]=P end end else for O,P in M(J)do if K(P)then N[#N+1]=P end end end return N end function i.reject(J,K,L)K=B(K)local M=A(J)local N={}if L then for O,P in M(J)do if not K(P)then N[O]=P end end else for O,P in M(J)do if not K(P)then N[#N+1]=P end end end return N end function i.merge(...)local J={}for K=1,select("#",...)do local L=select(K,...)local M=A(L)for N,O in M(L)do J[N]=O end end return J end function i.concat(...)local J={}for K=1,select("#",...)do local L=select(K,...)if L~=nil then local M=A(L)for N,O in M(L)do J[#J+1]=O end end end return J end function i.find(J,K)local L=A(J)for M,N in L(J)do if N==K then return M end end return nil end function i.match(J,K)K=B(K)local L=A(J)for M,N in L(J)do if K(N)then return N,M end end return nil end function i.count(J,K)local L=0 local M=A(J)if K then K=B(K)for N,O in M(J)do if K(O)then L=L+1 end end else if i.isarray(J)then return#J end for N in M(J)do L=L+1 end end return L end function i.slice(J,K,L)K=K and y(#J,K)or 1 L=L and y(#J,L)or#J local M={}for N=K<1 and 1 or K,L>#J and#J or L do M[#M+1]=J[N]end return M end function i.first(J,K)if not K then return J[1]end return i.slice(J,1,K)end function i.last(J,K)if not K then return J[#J]end return i.slice(J,-K,-1)end function i.invert(J)local K={}for L,M in j(J)do K[M]=L end return K end function i.pick(J,...)local K={}for L=1,select("#",...)do local M=select(L,...)K[M]=J[M]end return K end function i.keys(J)local K={}local L=A(J)for M in L(J)do K[#K+1]=M end return K end function i.clone(J)local K={}for L,M in j(J)do K[L]=M end return K end function i.fn(J,...)m(z(J),"expected a function as the first argument")local K={...}return function(...)local L=i.concat(K,{...})return J(n(L))end end function i.once(J,...)local K=i.fn(J,...)local L=false return function(...)if L then return end L=true return K(...)end end local C={}local D={}function i.memoize(J)local K={}return function(...)local L=K for M=1,select("#",...)do local N=select(M,...)or D L[N]=L[N]or{}L=L[N]end L[C]=L[C]or{J(...)}return n(L[C])end end function i.combine(...)local J=select('#',...)if J==0 then return v end if J==1 then local L=select(1,...)if not L then return v end m(z(L),"expected a function or nil")return L end local K={}for L=1,J do local M=select(L,...)if M~=nil then m(z(M),"expected a function or nil")K[#K+1]=M end end return function(...)for L,M in k(K)do M(...)end end end function i.call(J,...)if J then return J(...)end end function i.time(J,...)local K=os.clock()local L={J(...)}return(os.clock()-K),n(L)end local E={}function i.lambda(J)if not E[J]then local K,L=J:match([[^([%w,_ ]-)%->(.-)$]])m(K and L,"bad string lambda")local M="return function(" .. K .. ")\nreturn " .. L .. "\nend"E[J]=i.dostring(M)end return E[J]end local F local G={["boolean"]=o,["nil"]=o,["string"]=function(J)return string.format("%q",J)end,["number"]=function(J)if J~=J then return"0/0"elseif J==1/0 then return"1/0"elseif J==-1/0 then return"-1/0"end return o(J)end,["table"]=function(J,K)K=K or{}if K[J]then error("circular reference")end local L={}K[J]=true for M,N in j(J)do L[#L+1]="[" .. F(M,K) .. "]=" .. F(N,K)end K[J]=nil return"{" .. table.concat(L,",") .. "}"end}setmetatable(G,{__index=function(J,K)error("unsupported serialize type: " .. K)end})F=function(J,K)return G[l(J)](J,K)end function i.serialize(J)return F(J)end function i.deserialize(J)return i.dostring("return " .. J)end function i.split(J,K)if not K then return i.array(J:gmatch("([%S]+)"))else m(K~="","empty separator")local L=x(K)return i.array((J .. K):gmatch("(.-)(" .. L .. ")"))end end function i.trim(J,K)if not K then return J:match("^[%s]*(.-)[%s]*$")end K=x(K)return J:match("^[" .. K .. "]*(.-)[" .. K .. "]*$")end function i.wordwrap(J,K)K=K or 72 local L if l(K)=="number"then L=function(O)return#O>=K end else L=K end local M={}local N=""for O,P in J:gmatch("(%S+)(%s*)")do local Q=N .. O if L(Q)then table.insert(M,N .. "\n")N=O else N=Q end for R in P:gmatch(".")do if R=="\n"then table.insert(M,N .. "\n")N=""else N=N .. R end end end table.insert(M,N)return table.concat(M)end function i.format(J,K)if not K then return J end local L=function(M)return o(K[M]or K[p(M)]or"{" .. M .. "}")end return(J:gsub("{(.-)}",L))end function i.trace(...)local J=debug.getinfo(2,"Sl")local K={J.short_src .. ":" .. J.currentline .. ":"}for L=1,select("#",...)do local M=select(L,...)if l(M)=="number"then M=string.format("%g",i.round(M,.01))end K[#K+1]=o(M)end print(table.concat(K," "))end function i.dostring(J)return m((loadstring or load)(J))()end function i.uuid()local J=function(K)local L=math.random(16)-1 L=(K=="x")and(L+1)or(L%4)+9 return("0123456789abcdef"):sub(L,L)end return(("xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"):gsub("[xy]",J))end function i.hotswap(J)local K=i.clone(_G)local L={}local function M(R,S)if L[R]then return end L[R]=true local T,U=getmetatable(R),getmetatable(S)if T and U then M(T,U)end for V,W in j(S)do if l(W)=="table"then M(R[V],W)else R[V]=W end end end local N=nil local function O(R)for S in j(_G)do _G[S]=K[S]end N=i.trim(R)end local P,Q=pcall(e,J)Q=P and Q or nil xpcall(function()package.loaded[J]=nil local R=e(J)if l(Q)=="table"then M(Q,R)end for S,T in j(K)do if T~=_G[S]and l(T)=="table"then M(T,_G[S])_G[S]=T end end end,O)package.loaded[J]=Q if N then return nil,N end return Q end local H=function(J,K)K=K-1 local L=J[K]if L~=nil then return K,L end end function i.ripairs(J)return H,J,(#J+1)end function i.color(J,K)K=K or 1 local L,M,N,O L,M,N=J:match("#(%x%x)(%x%x)(%x%x)")if L then L=p(L,16)/0xff M=p(M,16)/0xff N=p(N,16)/0xff O=1 elseif J:match("rgba?%s*%([%d%s%.,]+%)")then local P=J:gmatch("[%d.]+")L=(P()or 0)/0xff M=(P()or 0)/0xff N=(P()or 0)/0xff O=P()or 1 else error(("bad color string '%s'"):format(J))end return L*K,M*K,N*K,O*K end local I={}I.__index=i.map(i.filter(i,z,true),function(J)return function(K,...)K._value=J(K._value,...)return K end end)I.__index.result=function(J)return J._value end function i.chain(J)return setmetatable({_value=J},I)end setmetatable(i,{__call=function(J,...)return i.chain(...)end})return i end)c("narrator.libs.classic",function(e,f,g,h)local i={}i.__index=i function i:new()end function i:extend()local j={}for k,l in pairs(self)do if k:find("__")==1 then j[k]=l end end j.__index=j j.super=self setmetatable(j,self)return j end function i:implement(...)for j,k in pairs({...})do for l,m in pairs(k)do if self[l]==nil and type(m)=="function"then self[l]=m end end end end function i:is(j)local k=getmetatable(self)while k do if k==j then return true end k=getmetatable(k)end return false end function i:__tostring()return"Object"end function i:__call(...)local j=setmetatable({},self)j:new(...)return j end return i end)c("narrator.enums",function(e,f,g,h)local i={engineVersion=1,item={text=1,alts=2,choice=3,condition=4,variable=5},sequence={cycle=1,stopping=2,once=3},readMode={text=1,choices=2,gathers=3,quit=4}}return i end)c("narrator.parser",function(e,f,g,h)local i=e("narrator.libs.lume")local j=e("narrator.enums")local k=e('narrator.libs.lulpeg')local l,m,n,o=k.S,k.C,k.P,k.V local p,q,r,s=k.Cb,k.Ct,k.Cc,k.Cg k.locale(k)local t={}local u={}function t.parse(v)local function w(bb)return#bb end local x=-1 local y=l(' \t')^0 local z=l(' \t\r\n')^0 local A=l('\r\n')^1 local B=r(nil)local C=n'->'local D=y*m('-'-C)local E=s(q(D^1)/w+B,'level')local F=s(q((y*m('+'))^1)/w,'level')*s(r(true),'sticky')local G=s(q((y*m('*'))^1)/w,'level')*s(r(false),'sticky')local H=F+G local I=(k.alpha+'_')*(k.alnum+'_')^0 local J=s('('*y*m(I)*y*')','label')local K=I*('.'*I)^-2 local L=s(C*y*m(K),'divert')local M=C*B local N='#'*y*o'text'local O=s(q(N*(y*N)^0),'tags')local P=y*'TODO:'*(1-A)^0 local Q=y*'//'*y*(1-A)^0 local R=y*'/*'*((n(1)-'*/')^0)*'*/'local S=Q+R local T=z*'}'local function U(bb)return s(r(bb),'type')end local function V(bb)local cb=bb~=nil and bb or false local db=cb and o'restrictedParagraph'or o'paragraph'return y*db^-1*y*o'multilineItem'*y*db^-1*z end local function W(bb,cb)local db=cb or false local eb=n(1-l(' \t'))-bb local fb=(y*eb^1)^1 local gb=m(fb*y)local hb=m(fb)*y local ib=m(fb)*y*#(O+A)return ib+(db and gb or hb)end local function X(bb)local cb=bb cb=cb:gsub('([%w_]*)%s*([%+%-])[%+%-]','%1 = %1 %2 1')cb=cb:gsub('([%w_]*)%s*([%+%-])=%s*(.*)','%1 = %1 %2 %3')local db,eb=cb:match('([%w_]*)%s*=%s*(.*)')return db or'',eb or bb end local Y=n({'root',root=z*o'items'+x,items=q(o'item'^0),item=V()+o'singlelineItem',singlelineItem=y*(o'global'+o'statement'+o'paragraph')*z,multilineItem=('{'*y*(o'sequence'+o'switch')*y*T)-o'inlineCondition',global=q(o'inclusion'*U('inclusion'))+q(o'list'*U('list'))+q(o'constant'*U('constant'))+q(o'variable'*U('variable')),inclusion='INCLUDE '*y*s(W(A+S),'filename'),list='LIST '*y*o'assignmentPair',constant='CONST '*y*o'assignmentPair',variable='VAR '*y*o'assignmentPair',statement=q(o'assignment'*U('assignment'))+q(o'knot'*U('knot'))+q(o'stitch'*U('stitch'))+q(o'choice'*U('choice'))+S+P,sectionName=m(I)*y*n'='^0,knot=n'=='*(n'='^0)*y*s(o'sectionName','knot'),stitch='='*y*s(o'sectionName','stitch'),assignment=E*y*'~'*y*o'assignmentTemp'*y*o'assignmentPair',assignmentTemp=s('temp'*r(true)+r(false),'temp'),assignmentPair=s(W(A+S)/X,'name')*s(p('name')/2,'value'),choiceCondition=s(o'expression'+B,'condition'),choiceFallback=H*y*o'labelOptional'*y*o'choiceCondition'*y*(L+M)*y*o'tagsOptional',choiceNormal=H*y*o'labelOptional'*y*o'choiceCondition'*y*s(o'text','text')*L^-1*y*o'tagsOptional',choice=o'choiceFallback'+o'choiceNormal',paragraph=q(E*y*(o'paragraphLabel'+o'paragraphText'+o'paragraphTags')*U('paragraph')),paragraphLabel=J*y*s(o'textOptional','parts')*y*o'tagsOptional',paragraphText=o'labelOptional'*y*s(o'textComplex','parts')*y*o'tagsOptional',paragraphTags=o'labelOptional'*y*s(o'textOptional','parts')*y*O,labelOptional=J+B,textOptional=o'textComplex'+B,tagsOptional=O+B,textComplex=q((q(s(o'inlineCondition','condition')+s(o'inlineSequence','sequence')+s(o'expression','expression')+s(o'text'+' ','text')*(L^-1)+L)-o'multilineItem')^1),text=W(A+L+S+N+l'{|}',true)-o'statement',expression='{'*y*W('}'+A)*y*'}',inlineCondition='{'*y*q(o'inlineIfElse'+o'inlineIf')*y*'}',inlineIf=s(W(l':}'+A),'condition')*y*':'*y*s(o'textComplex','success'),inlineIfElse=(o'inlineIf')*y*'|'*y*s(o'textComplex','failure'),inlineAltEmpty=q(q(s(y*r'','text')*y*L^-1)),inlineAlt=o'textComplex'+o'inlineAltEmpty',inlineAlts=q(((y*o'inlineAlt'*y*'|')^1)*y*o'inlineAlt'),inlineSequence='{'*y*('!'*y*q(s(o'inlineAlts','alts')*s(r('once'),'sequence'))+'&'*y*q(s(o'inlineAlts','alts')*s(r('cycle'),'sequence'))+'~'*y*q(s(o'inlineAlts','alts')*s(r('stopping'),'sequence')*s(r(true),'shuffle'))+q(s(o'inlineAlts','alts')*s(r('stopping'),'sequence')))*y*'}',switch=q((o'switchComparative'+o'switchConditional')*U('switch')),switchComparative=s(o'switchCondition','expression')*z*s(q((y*o'switchCase')^1),'cases'),switchConditional=s(q(o'switchCasesHeaded'+o'switchCasesOnly'),'cases'),switchCasesHeaded=o'switchIf'*((y*o'switchCase')^0),switchCasesOnly=z*((y*o'switchCase')^1),switchIf=q(s(o'switchCondition','condition')*z*s(q(o'switchItems'),'node')),switchCase=('-'-C)*y*o'switchIf',switchCondition=W(':'+A)*y*':'*y*S^-1,switchItems=(o'restrictedItem'-o'switchCase')^1,sequence=q((o'sequenceParams'*y*A*y*o'sequenceAlts')*U('sequence')),sequenceParams=(o'sequenceShuffleOptional'*y*o'sequenceType'+o'sequenceShuffle'*y*o'sequenceType'+o'sequenceShuffle'*y*o'sequenceTypeOptional')*y*':'*y*S^-1,sequenceShuffleOptional=o'sequenceShuffle'+s(r(false),'shuffle'),sequenceShuffle=s(n'shuffle'/function()return true end,'shuffle'),sequenceTypeOptional=o'sequenceType'+s(r'cycle','sequence'),sequenceType=s(n'cycle'+'stopping'+'once','sequence'),sequenceAlts=s(q((y*o'sequenceAlt')^1),'alts'),sequenceAlt=('-'-C)*z*q(o'sequenceItems'),sequenceItems=(o'restrictedItem'-o'sequenceAlt')^1,restrictedItem=V(true)+o'restrictedSinglelineItem',restrictedSinglelineItem=y*(o'global'+o'restrictedStatement'+o'restrictedParagraph'-T)*z,restrictedStatement=q(o'choice'*U('choice')+o'assignment'*U('assignment'))+S+P,restrictedParagraph=q((s(o'textComplex','parts')*y*o'tagsOptional'+s(o'textOptional','parts')*y*O)*U('paragraph'))})local Z=Y:match(v)local ab=u.constructBook(Z)return ab end function u.constructBook(v)local w={currentKnot='_',currentStitch='_',variablesToCompute={}}w.book={inclusions={},lists={},constants={},variables={},tree={_={_={}}}}w.book.version={engine=j.engineVersion,tree=1}w.nodesChain={w.book.tree[w.currentKnot][w.currentStitch]}u.addNode(w,v)u.clear(w.book.tree)u.computeVariables(w)return w.book end function u:addNode(v,w)local x=w~=nil and w or false for y,z in ipairs(v)do if x then z.level=nil if z.type=='choice'and z.divert==nil then z.type=nil end end if z.type=='inclusion'then u.addInclusion(self,z.filename)elseif z.type=='list'then u.addList(self,z.name,z.value)elseif z.type=='constant'then u.addConstant(self,z.name,z.value)elseif z.type=='variable'then u.addVariable(self,z.name,z.value)elseif z.type=='knot'then u.addKnot(self,z.knot)elseif z.type=='stitch'then u.addStitch(self,z.stitch)elseif z.type=='switch'then u.addSwitch(self,z.expression,z.cases)elseif z.type=='sequence'then u.addSequence(self,z.sequence,z.shuffle,z.alts)elseif z.type=='assignment'then u.addAssignment(self,z.level,z.name,z.value,z.temp)elseif z.type=='paragraph'then u.addParagraph(self,z.level,z.label,z.parts,z.tags)elseif z.type=='choice'then u.addChoice(self,z.level,z.sticky,z.label,z.condition,z.text,z.divert,z.tags)end end end function u:addInclusion(v)table.insert(self.book.inclusions,v)end function u:addList(v,w)local x=i.array(w:gmatch('[%w_%.]+'))self.book.lists[v]=x local y=i.array(w:gmatch('%b()'))y=i.map(y,function(z)return z:sub(2,#z-1)end)self.book.variables[v]={[v]={}}i.each(y,function(z)self.book.variables[v][v][z]=true end)end function u:addConstant(v,w)local x=i.deserialize(w)self.book.constants[v]=x end function u:addVariable(v,w)self.variablesToCompute[v]=w end function u:addKnot(v)self.currentKnot=v self.currentStitch='_'local w={}self.book.tree[self.currentKnot]={[self.currentStitch]=w}self.nodesChain={w}end function u:addStitch(v)if self.currentStitch=='_'then local x=self.book.tree[self.currentKnot]._ if#x==0 then local y={divert=v}table.insert(x,y)end end self.currentStitch=v local w={}self.book.tree[self.currentKnot][self.currentStitch]=w self.nodesChain={w}end function u:addSwitch(v,w)if v then for y,z in ipairs(w)do if z.condition~='else'then z.condition=v .. '==' .. z.condition end end end local x={condition={},success={}}for y,z in ipairs(w)do if z.condition=='else'then local A={}table.insert(self.nodesChain,A)u.addNode(self,z.node,true)table.remove(self.nodesChain)x.failure=A else local A={}table.insert(self.nodesChain,A)u.addNode(self,z.node,true)table.remove(self.nodesChain)table.insert(x.success,A)table.insert(x.condition,z.condition)end end u.addItem(self,nil,x)end function u:addSequence(v,w,x)local y={sequence=v,shuffle=w and true or nil,alts={}}for z,A in ipairs(x)do local B={}table.insert(self.nodesChain,B)u.addNode(self,A,true)table.remove(self.nodesChain)table.insert(y.alts,B)end u.addItem(self,nil,y)end function u:addAssignment(v,w,x,y)local z={temp=y or nil,var=w,value=x}u.addItem(self,v,z)end function u:addParagraph(v,w,x,y)local z=u.convertParagraphPartsToItems(x,true)z=z or{}if w~=nil or y~=nil then local A if#z>0 and z[1].condition==nil then A=z[1]else A={}table.insert(z,A)end A.label=w A.tags=y end for A,B in ipairs(z)do u.addItem(self,v,B)end end function u.convertParagraphPartsToItems(v,w)if v==nil then return nil end local x=w~=nil and w or false local y={}local z for A,B in ipairs(v)do if B.condition then z={condition=B.condition.condition,success=u.convertParagraphPartsToItems(B.condition.success),failure=u.convertParagraphPartsToItems(B.condition.failure)}table.insert(y,z)z=nil elseif B.sequence then z={sequence=B.sequence.sequence,shuffle=B.sequence.shuffle and true or nil,alts={}}for C,D in ipairs(B.sequence.alts)do table.insert(z.alts,u.convertParagraphPartsToItems(D))end table.insert(y,z)z=nil else local C=B.divert~=nil and B.text==nil if z==nil then z={text=(x or C)and''or'<>'}end if B.text then z.text=z.text .. B.text:gsub('%s+',' ')elseif B.expression then z.text=z.text .. '#' .. B.expression .. '#'end if B.divert then z.divert=B.divert z.text=#z.text>0 and(z.text .. '<>')or nil table.insert(y,z)z=nil else local D=v[A+1]local E=D and not(D.text or D.expression)if not D or E then if not x or E then z.text=z.text .. '<>'end table.insert(y,z)z=nil end end end end if x then local A=y[1]if A.text==nil and A.divert==nil then table.insert(y,1,{text=''})end local B=y[#y]if B.text==nil and B.divert==nil then table.insert(y,{text=''})elseif B.text~=nil and B.divert==nil then B.text=B.text:gsub('(.-)%s*$','%1')end end return y end function u:addChoice(v,w,x,y,z,A,B)local C={sticky=w or nil,condition=y,label=x,divert=A,tags=B}if z==nil then C.choice=0 else local D,E,F=z:match('(.*)%[(.*)%](.*)')D=D or z E=E or''F=F or''local G=(D .. F):gsub('%s+',' ')local H=(D .. E):gsub('%s+',' '):gsub('^%s*(.-)%s*$','%1')if A and#G>0 and G:match('%S+')then G=G .. '<>'else G=G:gsub('^%s*(.-)%s*$','%1')end C.text=G C.choice=H end u.addItem(self,v,C)if A==nil then C.node={}table.insert(self.nodesChain,C.node)end end function u:addItem(v,w)local x=(v~=nil and v>0)and v or#self.nodesChain while#self.nodesChain>x do table.remove(self.nodesChain)end local y=self.nodesChain[#self.nodesChain]table.insert(y,w)end function u:computeVariable(v,w)local x=self.book.constants[w]if x then self.book.variables[v]=x return end local y=w:match('%(([%s%w%.,_]*)%)')local z=y and i.array(y:gmatch('[%w_%.]+'))or{w}local A=y and{}or nil for B,C in ipairs(z)do local D,E=C:match('([%w_]+)%.([%w_]+)')E=E or C for F,G in pairs(self.book.lists)do local H=D==nil or D==F local I=i.find(G,E)if H and I then A=A or{}A[F]=A[F]or{}A[F][E]=true end end end if A then self.book.variables[v]=A else self.book.variables[v]=i.deserialize(w)end end function u:computeVariables()for v,w in pairs(self.variablesToCompute)do u.computeVariable(self,v,w)end end function u.clear(v)for w,x in pairs(v)do for y,z in pairs(x)do u.clearNode(z)end end end function u.clearNode(v)for w,x in ipairs(v)do if x.text~=nil and i.count(x)==1 then v[w]=x.text end if x.node~=nil then if#x.node==0 then x.node=nil else u.clearNode(x.node)end end if x.success~=nil then if type(x.condition)=='table'and#x.condition==1 then x.condition=x.condition[1]end if x.success[1]~=nil and x.success[1][1]~=nil then for y,z in ipairs(x.success)do u.clearNode(z)if#z==1 and type(z[1])=='string'then x.success[y]=z[1]end end if#x.success==1 then x.success=x.success[1]end else u.clearNode(x.success)if#x.success==1 and type(x.success[1])=='string'then x.success=x.success[1]end end if x.failure~=nil then u.clearNode(x.failure)if#x.failure==1 and type(x.failure[1])=='string'then x.failure=x.failure[1]end end end if x.alts~=nil then for y,z in ipairs(x.alts)do u.clearNode(z)if#z==1 and type(z[1])=='string'then x.alts[y]=z[1]end end end end end return t end)c("narrator.libs.lulpeg",function(e,f,g,h)local i,j,k,l,m=_ENV or _G,{},{},true,e local function n(...)local o=...if j[o]then return j[o]elseif k[o]then j[o]=k[o](o)return j[o]else return m(o)end end do local o=i k['util']=function(...)local p,q,r,s,t,u,v,w,x,y,z,A,B,C=getmetatable,setmetatable,load,loadstring,next,pairs,pcall,print,rawget,rawset,select,tostring,type,unpack local D,E,F=n"math",n"string",n"table"local G,H,I,J,K=D.max,E.match,E.gsub,F.concat,F.insert local L=n"compat"local function M()end local N,O,P if v and not L.lua52 and not l then local function kb(nb,ob)error("illegal global read: " .. A(ob),2)end local function lb(nb,ob,pb)error("illegal global write: " .. A(ob) .. ": " .. A(pb),2)end local mb=q({},{__index=kb,__newindex=lb})N=function()v(setfenv,3,mb)end function O(nb)x(mb,nb)end function P(nb,ob)y(mb,nb,ob)end else N=M end local Q=N()local R={nop=M,noglobals=N,getglobal=O,setglobal=P}R.unpack=F.unpack or C R.pack=F.pack or function(...)return{n=z('#',...),...}end if L.lua51 then local kb=r function R.load(lb,mb,nb,ob)local pb if B(lb)=='string'then pb=s(lb)else pb=kb(lb,mb)end if ob then setfenv(pb,ob)end return pb end else R.load=r end if L.luajit and L.jit then function R.max(kb)local lb=0 for mb=1,#kb do lb=G(lb,kb[mb])end return lb end elseif L.luajit then local kb=R.unpack function R.max(lb)local mb=#lb if mb<=30 or mb>10240 then local nb=0 for ob=1,#lb do local pb=lb[ob]if pb>nb then nb=pb end end return nb else return G(kb(lb))end end else local kb=R.unpack local lb=1000 function R.max(mb)local nb=#mb if nb==0 then return-1 end local ob=1 local pb=lb local qb=mb[1]repeat if pb>nb then pb=nb end local rb=G(kb(mb,ob,pb))if rb>qb then qb=rb end ob=ob+lb pb=pb+lb until ob>=nb return qb end end local function S(kb,lb)local mb=p(kb)or{}if mb.__mode then error("The mode has already been set on table " .. A(kb) .. ".")end mb.__mode=lb return q(kb,mb)end R.setmode=S function R.weakboth(kb)return S(kb,"kv")end function R.weakkey(kb)return S(kb,"k")end function R.weakval(kb)return S(kb,"v")end function R.strip_mt(kb)return q(kb,nil)end local T do local kb,lb=0,{}function T(mb)if not lb[mb]then kb=kb+1 lb[mb]=kb end return lb[mb]end end R.getuniqueid=T do local kb=0 function R.gensym()kb=kb+1 return"___SYM_" .. kb end end function R.passprint(...)w(...)return...end local U,V,W,X,Y local Z=2 local function ab(kb,lb)lb=lb or 0 Y={}local mb={}U(kb,mb,lb,lb)local nb=J(mb,"")return nb end R.val_to_str=ab function U(kb,lb,mb,nb)nb=nb or 1 if"string"==B(kb)then kb=I(kb,"\n","\n" .. (" "):rep(mb*Z+nb))if H(I(kb,"[^'\"]",""),'^"+$')then lb[#lb+1]=J{"'","",kb,"'"}else lb[#lb+1]=J{'"',I(kb,'"','\\"'),'"'}end elseif"cdata"==B(kb)then X(kb,lb,mb)elseif"table"==B(kb)then if Y[kb]then lb[#lb+1]=Y[kb]else Y[kb]=A(kb)W(kb,lb,mb)end else lb[#lb+1]=A(kb)end end function V(kb,lb,mb)if"string"==B(kb)and H(kb,"^[_%a][_%a%d]*$")then lb[#lb+1]=I(kb,"\n",(" "):rep(mb*Z+1) .. "\n")else lb[#lb+1]="[ "U(kb,lb,mb)lb[#lb+1]=" ]"end end function X(kb,lb,mb)lb[#lb+1]=(" "):rep(mb*Z)lb[#lb+1]="["w(#lb)for nb=0,#kb do if nb%16==0 and nb~=0 then lb[#lb+1]="\n"lb[#lb+1]=(" "):rep(mb*Z+2)end lb[#lb+1]=kb[nb]and 1 or 0 lb[#lb+1]=nb~=#kb and", "or""end w(#lb,lb[1],lb[2])lb[#lb+1]="]"end function W(kb,lb,mb)lb[#lb+1]=Y[kb]lb[#lb+1]="{\n"for nb,ob in u(kb)do local pb=1 lb[#lb+1]=(" "):rep((mb+1)*Z)V(nb,lb,mb+1)if lb[#lb]==" ]"and lb[#lb-2]=="[ "then pb=8+#lb[#lb-1]end lb[#lb+1]=" = "U(ob,lb,mb+1,pb)lb[#lb+1]="\n"end lb[#lb+1]=(" "):rep(mb*Z)lb[#lb+1]="}"end function R.expose(kb)w(ab(kb))return kb end function R.map(kb,lb,...)if B(kb)=="function"then kb,lb=lb,kb end local mb={}for nb=1,#kb do mb[nb]=lb(kb[nb],...)end return mb end function R.selfmap(kb,lb,...)if B(kb)=="function"then kb,lb=lb,kb end for mb=1,#kb do kb[mb]=lb(kb[mb],...)end return kb end local function bb(kb,lb,...)if B(kb)=="function"then kb,lb=lb,kb end local mb={}for nb,ob in t,kb do mb[nb]=lb(ob,...)end return mb end R.map_all=bb local function cb(kb,lb,mb)local nb=1 if not mb then mb=kb[1]nb=2 end for ob=nb,#kb do mb=lb(mb,kb[ob])end return mb end R.fold=cb local function db(kb,lb,mb)local nb=0 if not mb then mb=kb[#kb]nb=1 end for ob=#kb-nb,1,-1 do mb=lb(kb[ob],mb)end return mb end R.foldr=db local function eb(kb,lb,mb,nb)local ob=1 if not nb then nb=lb(kb[1])ob=2 end for pb=ob,#kb do nb=mb(nb,lb(kb[pb]))end return nb end R.map_fold=eb local function fb(kb,lb,mb,nb)local ob=0 if not nb then nb=lb(kb[#nb])ob=1 end for pb=#kb-ob,1,-1 do nb=mb(lb(kb[pb],nb))end return nb end R.map_foldr=eb function R.zip(kb,lb)local mb,nb={},G(#kb,#lb)for ob=1,nb do mb[ob]={kb[ob],lb[ob]}end return mb end function R.zip_all(kb,lb)local mb={}for nb,ob in u(kb)do mb[nb]={ob,lb[nb]}end for nb,ob in u(lb)do if mb[nb]==nil then mb[nb]={kb[nb],ob}end end return mb end function R.filter(kb,lb)local mb={}for nb=1,#kb do if lb(kb[nb])then K(mb,kb[nb])end end end local function gb(...)return...end R.id=gb local function hb(kb,lb)return kb and lb end local function ib(kb,lb)return kb or lb end function R.copy(kb)return bb(kb,gb)end function R.all(kb,lb)if lb then return eb(kb,lb,hb)else return cb(kb,hb)end end function R.any(kb,lb)if lb then return eb(kb,lb,ib)else return cb(kb,ib)end end function R.get(kb)return function(lb)return lb[kb]end end function R.lt(kb)return function(lb)return lb<kb end end function R.compose(kb,lb)return function(...)return kb(lb(...))end end function R.extend(kb,...)for lb=1,z('#',...)do for mb,nb in u((z(lb,...)))do kb[mb]=nb end end return kb end function R.setify(kb)local lb={}for mb=1,#kb do lb[kb[mb]]=true end return lb end function R.arrayify(...)return{...}end local function jb(kb)return kb .. ""end function R.checkstring(kb,lb)local mb,nb=v(jb,kb)if not mb then if lb==nil then lb="?"end error("bad argument to '" .. A(lb) .. "' (string expected, got " .. B(kb) .. ")",2)end return nb end return R end end do local o=i k['compiler']=function(...)local p,q,r,s,t,u,v,w,x=assert,error,pairs,print,rawset,select,setmetatable,tostring,type local y,z,A=n"string",n"table",n"util"local B=A.noglobals()local C,D,E,F,G,H=y.byte,y.sub,z.concat,z.insert,z.remove,A.unpack local I,J,K,L=A.load,A.map,A.map_all,A.pack local M=A.expose return function(N,O)local P,Q=O.evaluate,O.ispattern local R=N.charset local S={}local function T(kb,lb)if not Q(kb)then q("pattern expected")end local mb=kb.pkind if mb=="grammar"then lb={}elseif mb=="ref"or mb=="choice"or mb=="sequence"then if not lb[kb]then lb[kb]=S[mb](kb,lb)end return lb[kb]end if not kb.compiled then kb.compiled=S[kb.pkind](kb,lb)end return kb.compiled end O.compile=T local function U(kb,lb)for mb=lb,#kb do kb[mb]=nil end end local V,W,X=O.compile,O.evaluate,O.P local function Y(kb,lb)if kb==0 or kb==1 or kb==nil then return 1 elseif x(kb)~="number"then q"number or nil expected for the stating index"elseif kb>0 then return kb>lb and lb+1 or kb else return lb+kb<0 and 1 or lb+kb+1 end end local function Z()return{kind={},bounds={},openclose={},aux={}}end local function ab(kb,lb,mb,nb,...)if kb then s("@!!! Match !!!@",lb)end lb=X(lb)p(x(mb)=="string","string expected for the match subject")nb=Y(nb,#mb)if kb then s(("-"):rep(30))s(lb.pkind)O.pprint(lb)end local ob=T(lb,{})local pb=Z()local qb={grammars={},args={n=u('#',...),...},tags={}}local rb,sb,tb=ob(mb,nb,pb,1,qb)if kb then s("!!! Done Matching !!! success: ",rb,"final position",sb,"final cap index",tb,"#caps",#pb.openclose)end if rb then U(pb.kind,tb)U(pb.aux,tb)if kb then s("trimmed cap index = ",#pb+1)O.cprint(pb,mb,1)end local ub,vb,wb=W(pb,mb,1,1)if kb then s("#values",wb)M(ub)end if wb==0 then return sb else return H(ub,1,wb)end else if kb then s("Failed")end return nil end end function O.match(...)return ab(false,...)end function O.dmatch(...)return ab(true,...)end for kb,lb in r{"C","Cf","Cg","Cs","Ct","Clb","div_string","div_table","div_number","div_function"}do S[lb]=I(([=[
    local compile, expose, type, LL = ...
    return function (pt, ccache)
        local matcher, this_aux = compile(pt.pattern, ccache), pt.aux
        return function (sbj, si, caps, ci, state)
            local ref_ci = ci
            local kind, bounds, openclose, aux
                = caps.kind, caps.bounds, caps.openclose, caps.aux
            kind      [ci] = "XXXX"
            bounds    [ci] = si
            openclose [ci] = 0
            caps.aux       [ci] = (this_aux or false)
            local success
            success, si, ci
                = matcher(sbj, si, caps, ci + 1, state)
            if success then
                if ci == ref_ci + 1 then
                    caps.openclose[ref_ci] = si
                else
                    kind      [ci] = "XXXX"
                    bounds    [ci] = si
                    openclose [ci] = ref_ci - ci
                    aux       [ci] = this_aux or false
                    ci = ci + 1
                end
            else
                ci = ci - 1
            end
            return success, si, ci
        end
    end]=]):gsub("XXXX",lb),lb .. " compiler")(T,M,x,O)end S["Carg"]=function(kb,lb)local mb=kb.aux return function(nb,ob,pb,qb,rb)if rb.args.n<mb then q("reference to absent argument #" .. mb)end pb.kind[qb]="value"pb.bounds[qb]=ob if rb.args[mb]==nil then pb.openclose[qb]=1/0 pb.aux[qb]=1/0 else pb.openclose[qb]=ob pb.aux[qb]=rb.args[mb]end return true,ob,qb+1 end end for kb,lb in r{"Cb","Cc","Cp"}do S[lb]=I(([=[
    return function (pt, ccache)
        local this_aux = pt.aux
        return function (sbj, si, caps, ci, state)
            caps.kind      [ci] = "XXXX"
            caps.bounds    [ci] = si
            caps.openclose [ci] = si
            caps.aux       [ci] = this_aux or false
            return true, si, ci + 1
        end
    end]=]):gsub("XXXX",lb),lb .. " compiler")(M)end S["/zero"]=function(kb,lb)local mb=T(kb.pattern,lb)return function(nb,ob,pb,qb,rb)local sb,tb=mb(nb,ob,pb,qb,rb)U(pb.aux,qb)return sb,tb,qb end end local function bb(kb,...)return kb,L(...)end S["Cmt"]=function(kb,lb)local mb,nb=T(kb.pattern,lb),kb.aux return function(ob,pb,qb,rb,sb)local tb,ub,vb=mb(ob,pb,qb,rb,sb)if not tb then U(qb.aux,rb)return false,pb,rb end local wb,xb if vb==rb then wb,xb=bb(nb(ob,ub,D(ob,pb,ub-1)))else U(qb.aux,vb)U(qb.kind,vb)local yb,zb,Ab=P(qb,ob,rb)wb,xb=bb(nb(ob,ub,H(yb,1,Ab)))end if not wb then return false,pb,rb end if wb==true then wb=ub end if x(wb)=="number"and pb<=wb and wb<=#ob+1 then local yb,zb,Ab,Bb=qb.kind,qb.bounds,qb.openclose,qb.aux for Cb=1,xb.n do yb[rb]="value"zb[rb]=pb if xb[Cb]==nil then qb.openclose[rb]=1/0 qb.aux[rb]=1/0 else qb.openclose[rb]=wb qb.aux[rb]=xb[Cb]end rb=rb+1 end elseif x(wb)=="number"then q"Index out of bounds returned by match-time capture."else q("Match time capture must return a number, a boolean or nil" .. " as first argument, or nothing at all.")end return true,wb,rb end end S["string"]=function(kb,lb)local mb=kb.aux local nb=#mb return function(ob,pb,qb,rb,sb)local tb=pb-1 for ub=1,nb do local vb vb=C(ob,tb+ub)if vb~=mb[ub]then return false,pb,rb end end return true,pb+nb,rb end end S["char"]=function(kb,lb)return I(([=[
        local s_byte, s_char = ...
        return function(sbj, si, caps, ci, state)
            local c, nsi = s_byte(sbj, si), si + 1
            if c ~= __C0__ then
                return false, si, ci
            end
            return true, nsi, ci
        end]=]):gsub("__C0__",w(kb.aux)))(C,("").char)end local function cb(kb,lb,mb,nb,ob)return true,lb,nb end S["true"]=function(kb)return cb end local function db(kb,lb,mb,nb,ob)return false,lb,nb end S["false"]=function(kb)return db end local function eb(kb,lb,mb,nb,ob)return lb>#kb,lb,nb end S["eos"]=function(kb)return eb end local function fb(kb,lb,mb,nb,ob)local pb,qb=C(kb,lb),lb+1 if pb then return true,lb+1,nb else return false,lb,nb end end S["one"]=function(kb)return fb end S["any"]=function(kb)local lb=kb.aux if lb==1 then return fb else lb=kb.aux-1 return function(mb,nb,ob,pb,qb)local rb=nb+lb if rb<=#mb then return true,rb+1,pb else return false,nb,pb end end end end do local function kb(lb)for mb,nb in r(lb.aux)do if not Q(nb)then q(("rule 'A' is not a pattern"):gsub("A",w(mb)))end end end S["grammar"]=function(lb,mb)kb(lb)local nb=K(lb.aux,T,mb)local ob=nb[1]return function(pb,qb,rb,sb,tb)F(tb.grammars,nb)local ub,vb,wb=ob(pb,qb,rb,sb,tb)G(tb.grammars)return ub,vb,wb end end end local gb={kind={},bounds={},openclose={},aux={}}S["behind"]=function(kb,lb)local mb,nb=T(kb.pattern,lb),kb.aux return function(ob,pb,qb,rb,sb)if pb<=nb then return false,pb,rb end local tb=mb(ob,pb-nb,gb,rb,sb)gb.aux={}return tb,pb,rb end end S["range"]=function(kb)local lb=kb.aux return function(mb,nb,ob,pb,qb)local rb,sb=C(mb,nb),nb+1 for tb=1,#lb do local ub=lb[tb]if rb and ub[rb]then return true,sb,pb end end return false,nb,pb end end S["set"]=function(kb)local lb=kb.aux return function(mb,nb,ob,pb,qb)local rb,sb=C(mb,nb),nb+1 if lb[rb]then return true,sb,pb else return false,nb,pb end end end S["range"]=S.set S["ref"]=function(kb,lb)local mb=kb.aux local nb return function(ob,pb,qb,rb,sb)if not nb then if#sb.grammars==0 then q(("rule 'XXXX' used outside a grammar"):gsub("XXXX",w(mb)))elseif not sb.grammars[#sb.grammars][mb]then q(("rule 'XXXX' undefined in given grammar"):gsub("XXXX",w(mb)))end nb=sb.grammars[#sb.grammars][mb]end local tb,ub,vb=nb(ob,pb,qb,rb,sb)return tb,ub,vb end end local hb=[=[
            success, si, ci = XXXX(sbj, si, caps, ci, state)
            if success then
                return true, si, ci
            else
            end]=]local function ib(kb,lb,mb)if lb[2].pkind==kb then return T(lb[1],mb),ib(kb,lb[2],mb)else return T(lb[1],mb),T(lb[2],mb)end end S["choice"]=function(kb,lb)local mb={ib("choice",kb,lb)}local nb,ob={},{}for qb=1,#mb do local rb="ch" .. qb nb[#nb+1]=rb ob[#nb]=hb:gsub("XXXX",rb)end nb[#nb+1]="clear_captures"mb[#nb]=U local pb=E{"local ",E(nb,", "),[=[ = ...
        return function (sbj, si, caps, ci, state)
            local aux, success = caps.aux, false
            ]=],E(ob,"\n"),[=[--
            return false, si, ci
        end]=]}return I(pb,"Choice")(H(mb))end local jb=[=[
            success, si, ci = XXXX(sbj, si, caps, ci, state)
            if not success then
                return false, ref_si, ref_ci
            end]=]S["sequence"]=function(kb,lb)local mb={ib("sequence",kb,lb)}local nb,ob={},{}for qb=1,#mb do local rb="seq" .. qb nb[#nb+1]=rb ob[#nb]=jb:gsub("XXXX",rb)end nb[#nb+1]="clear_captures"mb[#nb]=U local pb=E{"local ",E(nb,", "),[=[ = ...
        return function (sbj, si, caps, ci, state)
            local ref_si, ref_ci, success = si, ci
            ]=],E(ob,"\n"),[=[
            return true, si, ci
        end]=]}return I(pb,"Sequence")(H(mb))end S["at most"]=function(kb,lb)local mb,nb=T(kb.pattern,lb),kb.aux nb=-nb return function(ob,pb,qb,rb,sb)local tb=true for ub=1,nb do tb,pb,rb=mb(ob,pb,qb,rb,sb)if not tb then break end end return true,pb,rb end end S["at least"]=function(kb,lb)local mb,nb=T(kb.pattern,lb),kb.aux if nb==0 then return function(ob,pb,qb,rb,sb)local tb,ub while true do local vb tb,ub=pb,rb vb,pb,rb=mb(ob,pb,qb,rb,sb)if not vb then pb,rb=tb,ub break end end return true,pb,rb end elseif nb==1 then return function(ob,pb,qb,rb,sb)local tb,ub local vb=true vb,pb,rb=mb(ob,pb,qb,rb,sb)if not vb then return false,pb,rb end while true do local wb tb,ub=pb,rb wb,pb,rb=mb(ob,pb,qb,rb,sb)if not wb then pb,rb=tb,ub break end end return true,pb,rb end else return function(ob,pb,qb,rb,sb)local tb,ub local vb=true for wb=1,nb do vb,pb,rb=mb(ob,pb,qb,rb,sb)if not vb then return false,pb,rb end end while true do local wb tb,ub=pb,rb wb,pb,rb=mb(ob,pb,qb,rb,sb)if not wb then pb,rb=tb,ub break end end return true,pb,rb end end end S["unm"]=function(kb,lb)if kb.pkind=="any"and kb.aux==1 then return eb end local mb=T(kb.pattern,lb)return function(nb,ob,pb,qb,rb)local sb,tb,ub=mb(nb,ob,pb,qb,rb)return not sb,ob,qb end end S["lookahead"]=function(kb,lb)local mb=T(kb.pattern,lb)return function(nb,ob,pb,qb,rb)local sb,tb,ub=mb(nb,ob,pb,qb,rb)return sb,ob,qb end end end end end do local o=i k['datastructures']=function(...)local p,q,r,s=getmetatable,pairs,setmetatable,type local t,u,v=n"math",n"table",n"util"local w=n"compat"local x if w.luajit then x=n"ffi"end local y=v.noglobals()local z,A,B=v.extend,v.load,v.max local C,D,E,F=t.max,u.concat,u.insert,u.sort local G={}local H,I,J local K={}local function L(cb)local db=r(A(D{"return{ [0]=false",(", false"):rep(cb)," }"})(),K)return db end if w.jit then local cb,db={v={}}function K.__index(eb,fb)if fb==nil or fb>eb.upper then return nil end return eb.v[fb]end function K.__len(eb)return eb.upper end function K.__newindex(eb,fb,gb)eb.v[fb]=gb end db=x.metatype('struct { int upper; bool v[?]; }',K)function H(eb)if s(eb)=="number"then local hb=db(eb+1)hb.upper=eb return hb end local fb=B(eb)cb.upper=fb if fb>255 then error"bool_set overflow"end local gb=db(fb+1)gb.upper=fb for hb=1,#eb do gb[eb[hb]]=true end return gb end function I(eb)return s(eb)=="cdata"and x.istype(eb,db)end J=I else function H(cb)if s(cb)=="number"then return L(cb)end local db=L(B(cb))for eb=1,#cb do db[cb[eb]]=true end return db end function I(cb)return false end function J(cb)return p(cb)==K end end local function M(cb,db)db=(cb<=db)and db or-1 local eb=H(db)for fb=cb,db do eb[fb]=true end return eb end local N,O={},{}local function P(cb,db)if s(cb)=="number"then db[cb]=true return db else return cb end end local function Q(cb,db)N[cb]=nil O[db]=nil end local function R(cb,db)local eb=C(s(cb)=="number"and cb or#cb,s(db)=="number"and db or#db)local fb,gb=P(cb,N),P(db,O)local hb=H(eb)for ib=0,eb do hb[ib]=fb[ib]or gb[ib]or false end Q(cb,db)return hb end local function S(cb,db)local eb={}for fb=0,255 do eb[fb]=cb[fb]and not db[fb]end return eb end local function T(cb)local db={}for eb=0,255 do db[#db+1]=(cb[eb]==true)and eb or nil end return D(db,", ")end G.binary={set={new=H,union=R,difference=S,tostring=T},Range=M,isboolset=I,isbyteset=J,isset=J}local U={}local function V(cb)local db=r({},U)for eb=1,#cb do db[cb[eb]]=true end return db end local function W(cb,db)for eb in q(cb)do db[eb]=true end return db end local function X(cb,db)cb,db=(s(cb)=="number")and V{cb}or cb,(s(db)=="number")and V{db}or db local eb=V{}W(cb,eb)W(db,eb)return eb end local function Y(cb,db)local eb={}cb,db=(s(cb)=="number")and V{cb}or cb,(s(db)=="number")and V{db}or db for fb in q(cb)do if cb[fb]and not db[fb]then eb[#eb+1]=fb end end return V(eb)end local function Z(cb)local db={}for eb in q(cb)do E(db,eb)end F(db)return D(db,",")end local function ab(cb)return(p(cb)==U)end local function bb(cb,db)local eb={}for fb=cb,db do eb[#eb+1]=fb end return V(eb)end G.other={set={new=V,union=X,tostring=Z,difference=Y,},Range=bb,isboolset=I,isbyteset=J,isset=ab,isrange=function(cb)return false end}return function(cb,db)local eb=(cb.options or{}).charset or"binary"if s(eb)=="string"then eb=(eb=="binary")and"binary"or"other"else eb=eb.binary and"binary"or"other"end return z(cb,G[eb])end end end do local o=i k['re']=function(...)return function(p,q)local r,s,t,u=tonumber,type,print,error local v=setmetatable local w=q local x=w local y=getmetatable(x.P(0))local z=_VERSION if z=="Lua 5.2"then o=nil end local A=w.P(1)local B={nl=w.P"\n"}local C local D local E local function F()x.locale(B)B.a=B.alpha B.c=B.cntrl B.d=B.digit B.g=B.graph B.l=B.lower B.p=B.punct B.s=B.space B.u=B.upper B.w=B.alnum B.x=B.xdigit B.A=A-B.a B.C=A-B.c B.D=A-B.d B.G=A-B.g B.L=A-B.l B.P=A-B.p B.S=A-B.s B.U=A-B.u B.W=A-B.w B.X=A-B.x C={}D={}E={}local fb={__mode="v"}v(C,fb)v(D,fb)v(E,fb)end F()local function G(fb,gb)local hb=gb and gb[fb]if not hb then u("undefined name: " .. fb)end return hb end local function H(fb,gb)local hb=(#fb<gb+20)and fb:sub(gb)or fb:sub(gb,gb+20) .. "..."hb=("pattern error near '%s'"):format(hb)u(hb,2)end local function I(fb,gb)local hb=x.P(true)while gb>=1 do if gb%2>=1 then hb=hb*fb end fb=fb*fb gb=gb/2 end return hb end local function J(fb,gb,hb)if s(hb)~="string"then return nil end local ib=#hb+gb if fb:sub(gb,ib-1)==hb then return ib else return nil end end local K=(B.space+"--"*(A-B.nl)^0)^0 local L=w.R("AZ","az","__")*w.R("AZ","az","__","09")^0 local M=K*"<-"local N=w.P"/"+")"+"}"+":}"+"~}"+"|}"+(L*M)+-1 L=w.C(L)local O=L*w.Carg(1)local P=w.C(w.R"09"^1)*K/r local Q="'"*w.C((A-"'")^0)*"'"+'"'*w.C((A-'"')^0)*'"'local R="%"*O/function(fb,gb)local hb=gb and gb[fb]or B[fb]if not hb then u("name '" .. fb .. "' undefined")end return hb end local S=w.Cs(A*(w.P"-"/"")*(A-"]"))/x.R local T=R+S+w.C(A)local U="["*(w.C(w.P"^"^-1))*w.Cf(T*(T-"]")^0,y.__add)/function(fb,gb)return fb=="^"and A-gb or gb end*"]"local function V(fb,gb,hb)if fb[gb]then u("'" .. gb .. "' already defined as a rule")else fb[gb]=hb end return fb end local function W(fb,gb)return V({fb},fb,gb)end local function X(fb,gb)if not gb then u("rule '" .. fb .. "' used outside a grammar")else return x.V(fb)end end local Y=w.P{"Exp",Exp=K*(w.V"Grammar"+w.Cf(w.V"Seq"*("/"*K*w.V"Seq")^0,y.__add));Seq=w.Cf(w.Cc(w.P"")*w.V"Prefix"^0,y.__mul)*(w.L(N)+H);Prefix="&"*K*w.V"Prefix"/y.__len+"!"*K*w.V"Prefix"/y.__unm+w.V"Suffix";Suffix=w.Cf(w.V"Primary"*K*((w.P"+"*w.Cc(1,y.__pow)+w.P"*"*w.Cc(0,y.__pow)+w.P"?"*w.Cc(-1,y.__pow)+"^"*(w.Cg(P*w.Cc(I))+w.Cg(w.C(w.S"+-"*w.R"09"^1)*w.Cc(y.__pow)))+"->"*K*(w.Cg((Q+P)*w.Cc(y.__div))+w.P"{}"*w.Cc(nil,w.Ct)+w.Cg(O/G*w.Cc(y.__div)))+"=>"*K*w.Cg(O/G*w.Cc(w.Cmt)))*K)^0,function(fb,gb,hb)return hb(fb,gb)end);Primary="("*w.V"Exp"*")"+Q/x.P+U+R+"{:"*(L*":"+w.Cc(nil))*w.V"Exp"*":}"/function(fb,gb)return x.Cg(gb,fb)end+"="*L/function(fb)return x.Cmt(x.Cb(fb),J)end+w.P"{}"/x.Cp+"{~"*w.V"Exp"*"~}"/x.Cs+"{|"*w.V"Exp"*"|}"/x.Ct+"{"*w.V"Exp"*"}"/x.C+w.P"."*w.Cc(A)+(L*-M+"<"*L*">")*w.Cb("G")/X;Definition=L*M*w.V"Exp";Grammar=w.Cg(w.Cc(true),"G")*w.Cf(w.V"Definition"/W*w.Cg(w.V"Definition")^0,V)/x.P}local Z=K*w.Cg(w.Cc(false),"G")*Y/x.P*(-A+H)local function ab(fb,gb)if x.type(fb)=="pattern"then return fb end local hb=Z:match(fb,1,gb)if not hb then u("incorrect pattern",3)end return hb end local function bb(fb,gb,hb)local ib=C[gb]if not ib then ib=ab(gb)C[gb]=ib end return ib:match(fb,hb or 1)end local function cb(fb,gb,hb)local ib=D[gb]if not ib then ib=ab(gb)/0 ib=x.P{x.Cp()*ib*x.Cp()+1*x.V(1)}D[gb]=ib end local jb,kb=ib:match(fb,hb or 1)if jb then return jb,kb-1 else return jb end end local function db(fb,gb,hb)local ib=E[gb]or{}E[gb]=ib local jb=ib[hb]if not jb then jb=ab(gb)jb=x.Cs((jb/hb+1)^0)ib[hb]=jb end return jb:match(fb)end local eb={compile=ab,match=bb,find=cb,gsub=db,updatelocale=F,}return eb end end end do local o=i k['charsets']=function(...)local p,q,r=n"string",n"table",n"util"local s=r.noglobals()local t=r.copy local u,v,w,x,y=p.char,p.sub,p.byte,q.concat,q.insert local function z(T)if T<128 then return 0,T elseif T<192 then error("Byte values between 0x80 to 0xBF cannot start a multibyte sequence")elseif T<224 then return 1,T-192 elseif T<240 then return 2,T-224 elseif T<248 then return 3,T-240 elseif T<252 then return 4,T-248 elseif T<254 then return 5,T-252 else error("Byte values between 0xFE and OxFF cannot start a multibyte sequence")end end local function A(T,U,V)U=U or 1 V=V or#T local W,X=0 for Y=U,V do local Z=w(T,Y)if W==0 then X=Y local ab ab,W=pcall(z,Z)if not ab then return false,X-1 end else if not(127<Z and Z<192)then return false,X-1 end W=W-1 end end if W~=0 then return nil,X-1 end return true,V end local function B(T,U)U=U and U+1 or 1 if U>#T then return end local V=w(T,U)local W,X=z(V)for Y=U+1,U+W do V=w(T,Y)X=X*64+(V-128)end return U+W,U,X end local function C(T,U)U=U and U+1 or 1 if U>#T then return end local V=z(w(T,U))return U+V,U,v(T,U,U+V)end local function D(T)local U={}for V,W,X in B,T do y(U,X)end return U end local function E(T)local U={}for V,W,X in C,T do y(U,X)end return U end local function F(T,U)if U>#T then return end local V=w(T,U)local W,X=z(V)for Y=U+1,U+W do V=w(T,Y)X=X*64+(V-128)end return X,U+W+1 end local function G(T)if not T then return end return function(U)local V={}local W,X=true while W do W,X=T(U,X)V[#V]=W end return V end end local function H(T)if not T then return end return function(U)local V={}for W=1,#U do y(V,T(U[W]))end return x(V)end end local function I(T,U)local V,W,X,Y,Z,ab=w(T,U)if V<128 then return V,U+1 elseif V<192 then error("Byte values between 0x80 to 0xBF cannot start a multibyte sequence")elseif V<224 then return(V-192)*64+w(T,U+1),U+2 elseif V<240 then Z,ab=w(T,U+1,U+2)return(V-224)*4096+Z%64*64+ab%64,U+3 elseif V<248 then Y,Z,ab=w(T,U+1,U+2,1+3)return(V-240)*262144+Y%64*4096+Z%64*64+ab%64,U+4 elseif V<252 then X,Y,Z,ab=w(T,U+1,U+2,1+3,U+4)return(V-248)*16777216+X%64*262144+Y%64*4096+Z%64*64+ab%64,U+5 elseif V<254 then W,X,Y,Z,ab=w(T,U+1,U+2,1+3,U+4,U+5)return(V-252)*1073741824+W%64*16777216+X%64*262144+Y%64*4096+Z%64*64+ab%64,U+6 else error("Byte values between 0xFE and OxFF cannot start a multibyte sequence")end end local function J(T,U)if U>#T then return end local V=z(w(T,U))return v(T,U,U+V),U+V+1 end local function K(T)if T<128 then return u(T)elseif T<2048 then return u(192+T/64,128+T%64)elseif T<55296 or 57343<T and T<65536 then return u(224+T/4096,128+T/64%64,128+T%64)elseif T<2097152 then return u(240+T/262144,128+T/4096%64,128+T/64%64,128+T%64)elseif T<67108864 then return u(248+T/16777216,128+T/262144%64,128+T/4096%64,128+T/64%64,128+T%64)elseif T<2147483648 then return u(252+T/1073741824,128+T/16777216%64,128+T/262144%64,128+T/4096%64,128+T/64%64,128+T%64)end error("Bad Unicode code point: " .. T .. ".")end local function L(T,U,V)U=U or 1 V=V or#T return true,V end local function M(T,U)U=U and U+1 or 1 if U>=#T then return end return U,U,v(T,U,U)end local function N(T,U)U=U and U+1 or 1 if U>#T then return end return U,U,w(T,U)end local function O(T)local U={}for V=1,#T do y(U,w(T,V))end return U end local function P(T)local U={}for V=1,#T do y(U,v(T,V,V))end return U end local function Q(T,U)return w(T,U),U+1 end local function R(T,U)return v(T,U,U),U+1 end local S={binary={name="binary",binary=true,validate=L,split_char=P,split_int=O,next_char=N,next_int=M,get_char=R,get_int=Q,tochar=u},["UTF-8"]={name="UTF-8",validate=A,split_char=E,split_int=D,next_char=C,next_int=B,get_char=J,get_int=F}}return function(T)local U=T.options.charset or"binary"if S[U]then T.charset=t(S[U])T.binary_split_int=O else error("NYI: custom charsets")end end end end do local o=i k['evaluator']=function(...)local p,q,r,s=select,tonumber,tostring,type local t,u,v=n"string",n"table",n"util"local w,x=t.sub,u.concat local y=v.unpack local z=v.noglobals()return function(A,B)local C={}local function D(I,J,K,L,M)local N,O=I.openclose,I.kind while O[L]and N[L]>=0 do L,M=C[O[L]](I,J,K,L,M)end return L,M end function C.C(I,J,K,L,M)if I.openclose[L]>0 then K[M]=w(J,I.bounds[L],I.openclose[L]-1)return L+1,M+1 end K[M]=false local N,O=D(I,J,K,L+1,M+1)K[M]=w(J,I.bounds[L],I.bounds[N]-1)return N+1,O end local function E(I,J,K)local L,M,N=I.aux,I.openclose,I.kind repeat K=K-1 local O,P=L[K],M[K]if P<0 then K=K+P end if P~=0 and N[K]=="Clb"and J==O then return K end until K==1 J=s(J)=="string"and"'" .. J .. "'"or r(J)error("back reference " .. J .. " not found")end function C.Cb(I,J,K,L,M)local N=E(I,I.aux[L],L)N,M=C.Cg(I,J,K,N,M)return L+1,M end function C.Cc(I,J,K,L,M)local N=I.aux[L]for O=1,N.n do M,K[M]=M+1,N[O]end return L+1,M end C["Cf"]=function()error("NYI: Cf")end function C.Cf(I,J,K,L,M)if I.openclose[L]>0 then error"No First Value"end local N,O,P=I.aux[L],{}L=L+1 L,P=C[I.kind[L]](I,J,O,L,1)if P==1 then error"No first value"end local Q=O[1]while I.kind[L]and I.openclose[L]>=0 do L,P=C[I.kind[L]](I,J,O,L,1)Q=N(Q,y(O,1,P-1))end K[M]=Q return L+1,M+1 end function C.Cg(I,J,K,L,M)if I.openclose[L]>0 then K[M]=w(J,I.bounds[L],I.openclose[L]-1)return L+1,M+1 end local N,O=D(I,J,K,L+1,M)if O==M then K[O]=w(J,I.bounds[L],I.bounds[N]-1)O=O+1 end return N+1,O end function C.Clb(I,J,K,L,M)local N=I.openclose if N[L]>0 then return L+1,M end local O=0 repeat if N[L]==0 then O=O+1 elseif N[L]<0 then O=O-1 end L=L+1 until O==0 return L,M end function C.Cp(I,J,K,L,M)K[M]=I.bounds[L]return L+1,M+1 end function C.Ct(I,J,K,L,M)local N,O,P=I.aux,I.openclose,I.kind local Q={}K[M]=Q if O[L]>0 then return L+1,M+1 end local R,S=1,{}L=L+1 while P[L]and O[L]>=0 do if P[L]=="Clb"then local T,U=N[L],1 L,U=C.Cg(I,J,S,L,1)if U~=1 then Q[T]=S[1]end else L,R=C[P[L]](I,J,Q,L,R)end end return L+1,M+1 end local F=1/0 function C.value(I,J,K,L,M)local N if I.aux[L]~=F or I.openclose[L]~=F then N=I.aux[L]end K[M]=N return L+1,M+1 end function C.Cs(I,J,K,L,M)if I.openclose[L]>0 then K[M]=w(J,I.bounds[L],I.openclose[L]-1)else local N,O,P=I.bounds,I.kind,I.openclose local Q,R,S,T,U=N[L],{},{},1,1 local V L=L+1 while P[L]>=0 do V=N[L]R[T]=w(J,Q,V-1)T=T+1 L,U=C[O[L]](I,J,S,L,1)if U>1 then R[T]=S[1]T=T+1 Q=P[L-1]>0 and P[L-1]or N[L-1]else Q=V end end R[T]=w(J,Q,N[L]-1)K[M]=x(R)end return L+1,M+1 end local function G(I,J,...)local K=p('#',...)for L=1,K do J,I[J]=J+1,p(L,...)end return J end function C.div_function(I,J,K,L,M)local N=I.aux[L]local O,P if I.openclose[L]>0 then O,P={w(J,I.bounds[L],I.openclose[L]-1)},2 else O={}L,P=D(I,J,O,L+1,1)end L=L+1 M=G(K,M,N(y(O,1,P-1)))return L,M end function C.div_number(I,J,K,L,M)local N=I.aux[L]local O,P if I.openclose[L]>0 then O,P={w(J,I.bounds[L],I.openclose[L]-1)},2 else O={}L,P=D(I,J,O,L+1,1)end L=L+1 if N>=P then error("no capture '" .. N .. "' in /number capture.")end K[M]=O[N]return L,M+1 end local function H(I,J)local K=I.openclose local L={open=I.bounds[J]}if K[J]>0 then L.close=K[J]return J+1,L,0 end local M=J local N=1 J=J+1 repeat local O=K[J]if N==1 and O>=0 then L[#L+1]=J end if O==0 then N=N+1 elseif O<0 then N=N-1 end J=J+1 until N==0 L.close=I.bounds[J-1]return J,L,#L end function C.div_string(I,J,K,L,M)local N,O local P local Q,R={},{}local S=I.aux[L]L,O,N=H(I,L)K[M]=S:gsub("%%([%d%%])",function(T)if T=="%"then return"%"end T=q(T)if not Q[T]then if T>N then error("no capture at index " .. T .. " in /string capture.")end if T==0 then Q[T]=w(J,O.open,O.close-1)else local U,V=C[I.kind[O[T]]](I,J,R,O[T],1)if V==1 then error("no values in capture at index" .. T .. " in /string capture.")end Q[T]=R[1]end end return Q[T]end)return L,M+1 end function C.div_table(I,J,K,L,M)local N=I.aux[L]local O if I.openclose[L]>0 then O=w(J,I.bounds[L],I.openclose[L]-1)else local P,Q={}L,Q=D(I,J,P,L+1,1)O=P[1]end L=L+1 if N[O]then K[M]=N[O]return L,M+1 else return L,M end end function B.evaluate(I,J,K)local L={}local M,N=D(I,J,L,K,1)return L,1,N-1 end end end end do local o=i k['printers']=function(...)return function(p,q)local r,s,t,u,v=ipairs,pairs,print,tostring,type local w,x,y=n"string",n"table",n"util"local z=p.set.tostring local A=y.noglobals()local B,C,D=w.char,w.sub,x.concat local E,F,G=y.expose,y.load,y.map local H={["\f"]="\\f",["\n"]="\\n",["\r"]="\\r",["\t"]="\\t",["\v"]="\\v",["\127"]="\\ESC"}local function I(R,S)if S[2].pkind==R then return S[1],I(R,S[2])else return S[1],S[2]end end for R=0,8 do H[B(R)]="\\" .. R end for R=14,31 do H[B(R)]="\\" .. R end local function J(R)return R:gsub("%c",H)end local function K(R)return B(F("return " .. z(R))())end local L={}local function M(R,S,T)return L[R.pkind](R,S,T)end function q.pprint(R)local S=q.P(R)t"\nPrint pattern"M(S,"","")t"--- /pprint\n"return R end for R,S in s{string=[[ "P( \""..escape(pt.as_is).."\" )"       ]],char=[[ "P( \""..escape(to_char(pt.aux)).."\" )"]],["true"]=[[ "P( true )"                     ]],["false"]=[[ "P( false )"                    ]],eos=[[ "~EOS~"                         ]],one=[[ "P( one )"                      ]],any=[[ "P( "..pt.aux.." )"             ]],set=[[ "S( "..'"'..escape(set_repr(pt.aux))..'"'.." )" ]],["function"]=[[ "P( "..pt.aux.." )"             ]],ref=[[
        "V( ",
            (type(pt.aux) == "string" and "\""..pt.aux.."\"")
                          or tostring(pt.aux)
        , " )"
        ]],range=[[
        "R( ",
            escape(t_concat(map(
                pt.as_is,
                function(e) return '"'..e..'"' end)
            , ", "))
        ," )"
        ]]}do L[R]=F(([==[
        local k, map, t_concat, to_char, escape, set_repr = ...
        return function (pt, offset, prefix)
            print(t_concat{offset,prefix,XXXX})
        end
    ]==]):gsub("XXXX",S),R .. " printer")(R,G,D,B,J,K)end for R,S in s{["behind"]=[[ LL_pprint(pt.pattern, offset, "B ") ]],["at least"]=[[ LL_pprint(pt.pattern, offset, pt.aux.." ^ ") ]],["at most"]=[[ LL_pprint(pt.pattern, offset, pt.aux.." ^ ") ]],unm=[[LL_pprint(pt.pattern, offset, "- ")]],lookahead=[[LL_pprint(pt.pattern, offset, "# ")]],choice=[[
        print(offset..prefix.."+")
        local ch, i = {}, 1
        while pt.pkind == "choice" do
            ch[i], pt, i = pt[1], pt[2], i + 1
        end
        ch[i] = pt
        map(ch, LL_pprint, offset.." :", "")
        ]],sequence=[=[
        print(offset..prefix.."*")
        local acc, p2 = {}
        offset = offset .. " |"
        while true do
            if pt.pkind ~= "sequence" then -- last element
                if pt.pkind == "char" then
                    acc[#acc + 1] = pt.aux
                    print(offset..'P( "'..s.char(u.unpack(acc))..'" )')
                else
                    if #acc ~= 0 then
                        print(offset..'P( "'..s.char(u.unpack(acc))..'" )')
                    end
                    LL_pprint(pt, offset, "")
                end
                break
            elseif pt[1].pkind == "char" then
                acc[#acc + 1] = pt[1].aux
            elseif #acc ~= 0 then
                print(offset..'P( "'..s.char(u.unpack(acc))..'" )')
                acc = {}
                LL_pprint(pt[1], offset, "")
            else
                LL_pprint(pt[1], offset, "")
            end
            pt = pt[2]
        end
        ]=],grammar=[[
        print(offset..prefix.."Grammar")
        for k, pt in pairs(pt.aux) do
            local prefix = ( type(k)~="string"
                             and tostring(k)
                             or "\""..k.."\"" )
            LL_pprint(pt, offset.."  ", prefix .. " = ")
        end
    ]]}do L[R]=F(([[
        local map, LL_pprint, pkind, s, u, flatten = ...
        return function (pt, offset, prefix)
            XXXX
        end
    ]]):gsub("XXXX",S),R .. " printer")(G,M,v,w,y,I)end for R,S in s{"C","Cs","Ct"}do L[S]=function(T,U,V)t(U .. V .. S)M(T.pattern,U .. "  ","")end end for R,S in s{"Cg","Clb","Cf","Cmt","div_number","/zero","div_function","div_table"}do L[S]=function(T,U,V)t(U .. V .. S .. " " .. u(T.aux or""))M(T.pattern,U .. "  ","")end end L["div_string"]=function(R,S,T)t(S .. T .. '/string "' .. u(R.aux or"") .. '"')M(R.pattern,S .. "  ","")end for R,S in s{"Carg","Cp"}do L[S]=function(T,U,V)t(U .. V .. S .. "( " .. u(T.aux) .. " )")end end L["Cb"]=function(R,S,T)t(S .. T .. "Cb( \"" .. R.aux .. "\" )")end L["Cc"]=function(R,S,T)t(S .. T .. "Cc(" .. D(G(R.aux,u),", ") .. " )")end local N={}local O="   "local function P(R)R=u(R)R=R .. "." .. ((" "):rep(4-#R))return R end local function Q(R,S,T,U,V)local W,X=R.openclose,R.kind T=T or 0 while X[S]and W[S]>=0 do if R.openclose[S]>0 then t(D({P(V),O:rep(T),R.kind[S],": start = ",u(R.bounds[S])," finish = ",u(R.openclose[S]),R.aux[S]and" aux = "or"",R.aux[S]and(v(R.aux[S])=="string"and'"' .. u(R.aux[S]) .. '"'or u(R.aux[S]))or""," \t",C(U,R.bounds[S],R.openclose[S]-1)}))if v(R.aux[S])=="table"then E(R.aux[S])end else local Y=R.kind[S]local Z=R.bounds[S]t(D({P(V),O:rep(T),Y,": start = ",Z,R.aux[S]and" aux = "or"",R.aux[S]and(v(R.aux[S])=="string"and'"' .. u(R.aux[S]) .. '"'or u(R.aux[S]))or""}))S,V=Q(R,S+1,T+1,U,V+1)t(D({P(V),O:rep(T),"/",Y," finish = ",u(R.bounds[S])," \t",C(U,Z,(R.bounds[S]or 1)-1)}))end V=V+1 S=S+1 end return S,V end function q.cprint(R,S,T)S=S or 1 t"\nCapture Printer:\n================"Q(R,S,0,T,1)t"================\n/Cprinter\n"end return{pprint=q.pprint,cprint=q.cprint}end end end do local o=i k['analyzer']=function(...)local p=n"util"local q,r=p.nop,p.weakkey local s,t,u=r{},r{},r{}return{hasV=q,hasCmt=q,length=q,hasCapture=q}end end do local o=i k['locale']=function(...)local p=n"util".extend local q=n"util".noglobals()return function(r,s)local t,u=s.R,s.S local v={}v["cntrl"]=t"\0\31"+"\127"v["digit"]=t"09"v["lower"]=t"az"v["print"]=t" ~"v["space"]=u" \f\n\r\t\v"v["upper"]=t"AZ"v["alpha"]=v["lower"]+v["upper"]v["alnum"]=v["alpha"]+v["digit"]v["graph"]=v["print"]-v["space"]v["punct"]=v["graph"]-v["alnum"]v["xdigit"]=v["digit"]+t"af"+t"AF"function s.locale(w)return p(w or{},v)end end end end do local o=i k['match']=function(...)end end do local o=i k['factorizer']=function(...)local p,q,r,s=ipairs,pairs,print,setmetatable local t=n"util"local u,v,w,x=t.id,t.nop,t.setify,t.weakkey local y=t.noglobals()local function z(E,F,G)local H,I=G.id,G.brk if E==H then return true,F elseif F==H then return true,E elseif E==I then return true,I else return false end end local A=w{"unm","lookahead","C","Cf","Cg","Cs","Ct","/zero"}local B=w{"behind","at least","at most","Clb","Cmt","div_string","div_number","div_table","div_function"}local C=w{"char","set","range"}local D D=s({},{__mode="k",__index=function(E,F)local G,H=F.pkind,false if G=="Cmt"or G=="ref"then H=true elseif A[G]or B[G]then H=D[F.pattern]elseif G=="choice"or G=="sequence"then H=D[F[1]]or D[F[2]]end D[F]=H return H end})return function(E,F)if E.options.factorize==false then return{choice=v,sequence=v,lookahead=v,unm=v}end local G,H=E.constructors,F.P local I,J=G.constant.truept,G.constant.falsept local K=E.set.union local L=w{"char","set"}local M={["/zero"]="__div",["div_number"]="__div",["div_string"]="__div",["div_table"]="__div",["div_function"]="__div",["at least"]="__exp",["at most"]="__exp",["Clb"]="Cg",}local function N(R,S)do local V,W=z(R,S,{id=J,brk=I})if V then return W end end local T,U=R.pkind,S.pkind if R==S and not D[R]then return R elseif T=="choice"then local V,W={},1 while R.pkind=="choice"do V[W],R,W=R[1],R[2],W+1 end V[W]=R for X=W,1,-1 do S=V[X]+S end return S elseif L[T]and L[U]then return G.aux("set",K(R.aux,S.aux))elseif L[T]and U=="any"and S.aux==1 or L[U]and T=="any"and R.aux==1 then return T=="any"and R or S elseif T==U then if(A[T]or B[T])and(R.aux==S.aux)then return F[M[T]or T](R.pattern+S.pattern,R.aux)elseif(T==U)and T=="sequence"then if R[1]==S[1]and not D[R[1]]then return R[1]*(R[2]+S[2])end end end return false end local function O(R)return R end local function P(R,S)do local V,W=z(R,S,{id=I,brk=J})if V then return W end end local T,U=R.pkind,S.pkind if T=="sequence"then local V,W={},1 while R.pkind=="sequence"do V[W],R,W=R[1],R[2],W+1 end V[W]=R for X=W,1,-1 do S=V[X]*S end return S elseif(T=="one"or T=="any")and(U=="one"or U=="any")then return H(R.aux+S.aux)end return false end local function Q(R)if R==I then return J elseif R==J then return I elseif R.pkind=="unm"then return#R.pattern elseif R.pkind=="lookahead"then return-R.pattern end end return{choice=N,lookahead=O,sequence=P,unm=Q}end end end do local o=i k['API']=function(...)local p,q,r,s,t,u,v,w,x,y,z=assert,error,ipairs,pairs,pcall,print,n,select,tonumber,tostring,type local A,B=v"table",v"util"local C=B.noglobals()local D=A.concat local E,F,G,H,I,J,K,L,M=B.checkstring,B.copy,B.fold,B.load,B.map_fold,B.map_foldr,B.setify,B.pack,B.unpack local function N(O,P)q("Character at position " .. O+1 .. " is not a valid " .. P .. " one.",2)end return function(O,P)local Q=O.charset local R,S=O.constructors,P.ispattern local T,U,V=R.constant.truept,R.constant.falsept,R.constant.Cppt local W,X=Q.split_int,Q.validate local Y,Z,ab,bb=O.Range,O.set.new,O.set.union,O.set.tostring local cb,db,eb,fb local function gb(yb)return R.aux("char",yb)end local function hb(...)local yb,zb=(...),w('#',...)if zb==0 then q"bad argument #1 to 'P' (value expected)"end local Ab=z(yb)if S(yb)then return yb elseif Ab=="function"then return P.Cmt("",yb)elseif Ab=="string"then local Bb,Cb=X(yb)if not Bb then N(Cb,Q.name)end if yb==""then return T end return J(W(yb),gb,O.sequence)elseif Ab=="table"then local Bb=F(yb)if Bb[1]==nil then q("grammar has no initial rule")end if not S(Bb[1])then Bb[1]=P.V(Bb[1])end return R.none("grammar",Bb)elseif Ab=="boolean"then return yb and T or U elseif Ab=="number"then if yb==0 then return T elseif yb>0 then return R.aux("any",yb)else return-R.aux("any",-yb)end else q("bad argument #1 to 'P' (lpeg-pattern expected, got " .. Ab .. ")")end end P.P=hb local function ib(yb)if yb==""then return U else local zb yb=E(yb,"S")return R.aux("set",Z(W(yb)),yb)end end P.S=ib local function jb(...)if w('#',...)==0 then return hb(false)else local yb=Y(1,0)for zb,Ab in r{...}do Ab=E(Ab,"R")p(#Ab==2,"bad argument #1 to 'R' (range must have two characters)")yb=ab(yb,Y(M(W(Ab))))end return R.aux("set",yb)end end P.R=jb local function kb(yb)p(yb~=nil)return R.aux("ref",yb)end P.V=kb do local yb=K{"set","range","one","char"}local zb=K{"true","false","lookahead","unm"}local Ab=K{"Carg","Cb","C","Cf","Cg","Cs","Ct","/zero","Clb","Cmt","Cc","Cp","div_string","div_number","div_table","div_function","at least","at most","behind"}local function Bb(Cb,Db,Eb)local Fb=Cb.pkind if Ab[Fb]then return false elseif yb[Fb]then return 1 elseif zb[Fb]then return 0 elseif Fb=="string"then return#Cb.as_is elseif Fb=="any"then return Cb.aux elseif Fb=="choice"then local Gb,Hb=Bb(Cb[1],Db,Eb),Bb(Cb[2],Db,Eb)return(Gb==Hb)and Gb elseif Fb=="sequence"then local Gb,Hb=Bb(Cb[1],Db,Eb),Bb(Cb[2],Db,Eb)return Gb and Hb and Gb+Hb elseif Fb=="grammar"then if Cb.aux[1].pkind=="ref"then return Bb(Cb.aux[Cb.aux[1].aux],Cb.aux,{})else return Bb(Cb.aux[1],Cb.aux,{})end elseif Fb=="ref"then if Eb[Cb]then return false end Eb[Cb]=true return Bb(Db[Cb.aux],Db,Eb)else u(Fb,"is not handled by fixedlen()")end end function P.B(Cb)Cb=hb(Cb)local Db=Bb(Cb)p(Db,"A 'behind' pattern takes a fixed length pattern as argument.")if Db>=260 then q("Subpattern too long in 'behind' pattern constructor.")end return R.both("behind",Cb,Db)end end local function lb(yb,zb)return y(yb) .. y(zb)end local function mb(yb,zb)local Ab=y(yb) .. y(zb)local Bb=O.ptcache.choice[Ab]if not Bb then Bb=cb(yb,zb)or R.binary("choice",yb,zb)O.ptcache.choice[Ab]=Bb end return Bb end function P.__add(yb,zb)return mb(hb(yb),hb(zb))end local function nb(yb,zb)local Ab=y(yb) .. y(zb)local Bb=O.ptcache.sequence[Ab]if not Bb then Bb=eb(yb,zb)or R.binary("sequence",yb,zb)O.ptcache.sequence[Ab]=Bb end return Bb end O.sequence=nb function P.__mul(yb,zb)return nb(hb(yb),hb(zb))end local function ob(yb)if yb==T or yb==U or yb.pkind=="unm"or yb.pkind=="lookahead"then return yb end return R.subpt("lookahead",yb)end P.__len=ob P.L=ob local function pb(yb)return fb(yb)or R.subpt("unm",yb)end P.__unm=pb local function qb(yb,zb)yb,zb=hb(yb),hb(zb)return pb(zb)*yb end P.__sub=qb local function rb(yb,zb)local Ab Ab,zb=t(x,zb)p(Ab and z(zb)=="number","Invalid type encountered at right side of '^'.")return R.both((zb<0 and"at most"or"at least"),yb,zb)end P.__pow=rb for yb,zb in s{"C","Cs","Ct"}do P[zb]=function(Ab)Ab=hb(Ab)return R.subpt(zb,Ab)end end P["Cb"]=function(yb)return R.aux("Cb",yb)end P["Carg"]=function(yb)p(z(yb)=="number","Number expected as parameter to Carg capture.")p(0<yb and yb<=200,"Argument out of bounds in Carg capture.")return R.aux("Carg",yb)end local function sb()return V end P.Cp=sb local function tb(...)return R.none("Cc",L(...))end P.Cc=tb for yb,zb in s{"Cf","Cmt"}do local Ab="Function expected in " .. zb .. " capture"P[zb]=function(Bb,Cb)p(z(Cb)=="function",Ab)Bb=hb(Bb)return R.both(zb,Bb,Cb)end end local function ub(yb,zb)yb=hb(yb)if zb~=nil then return R.both("Clb",yb,zb)else return R.subpt("Cg",yb)end end P.Cg=ub local vb=K{"string","number","table","function"}local function wb(yb,zb)if S(zb)then q"The right side of a '/' capture cannot be a pattern."elseif not vb[z(zb)]then q("The right side of a '/' capture must be of type " .. "string, number, table or function.")end local Ab if zb==0 then Ab="/zero"else Ab="div_" .. z(zb)end return R.both(Ab,yb,zb)end P.__div=wb if O.proxymt then for yb,zb in s(P)do if yb:match"^__"then O.proxymt[yb]=zb end end else P.__index=P end local xb=O.factorizer(O,P)cb,db,eb,fb=xb.choice,xb.lookahead,xb.sequence,xb.unm end end end do local o=i k['constructors']=function(...)local p,q,r,s,t=getmetatable,ipairs,newproxy,print,setmetatable local u,v,w=n"table",n"util",n"compat"local x=u.concat local y,z,A,B,C,D=v.copy,v.getuniqueid,v.id,v.map,v.weakkey,v.weakval local E=v.noglobals()local F={constant={"Cp","true","false"},aux={"string","any","char","range","set","ref","sequence","choice","Carg","Cb"},subpt={"unm","lookahead","C","Cf","Cg","Cs","Ct","/zero"},both={"behind","at least","at most","Clb","Cmt","div_string","div_number","div_table","div_function"},none="grammar","Cc"}return function(G,H)local I=G.set.tostring local J,K if w.proxies and not w.lua52_len then local R=C{}local S={__index=H}local T=r(true)K=p(T)G.proxymt=K function K:__index(U)return R[self][U]end function K:__newindex(U,V)R[self][U]=V end function H.getdirect(U)return R[U]end function J(U)local V=r(T)t(U,S)R[V]=U return V end else if H.warnings and not w.lua52_len then s("Warning: The `__len` metamethod won't work with patterns, " .. "use `LL.L(pattern)` for lookaheads.")end K=H function H.getdirect(R)return R end function J(R)return t(R,H)end end G.newpattern=J local function L(R)return p(R)==K end H.ispattern=L function H.type(R)if L(R)then return"pattern"else return nil end end local M,N local function O()M,N={},C{}G.ptcache=M for R,S in q(F.aux)do M[S]=D{}end for R,S in q(F.subpt)do M[S]=D{}end for R,S in q(F.both)do M[S]={}end return M end H.resetptcache=O O()local P={}G.constructors=P P["constant"]={truept=J{pkind="true"},falsept=J{pkind="false"},Cppt=J{pkind="Cp"}}local Q={string=function(R,S)return S end,table=y,set=function(R,S)return I(R)end,range=function(R,S)return x(S,"|")end,sequence=function(R,S)return x(B(z,R),"|")end}Q.choice=Q.sequence P["aux"]=function(R,S,T)local U=M[R]local V=(Q[R]or A)(S,T)if not U[V]then U[V]=J{pkind=R,aux=S,as_is=T}end return U[V]end P["none"]=function(R,S)return J{pkind=R,aux=S}end P["subpt"]=function(R,S)local T=M[R]if not T[S]then T[S]=J{pkind=R,pattern=S}end return T[S]end P["both"]=function(R,S,T)local U=M[R][T]if not U then M[R][T]=D{}U=M[R][T]end if not U[S]then U[S]=J{pkind=R,pattern=S,aux=T,cache=U}end return U[S]end P["binary"]=function(R,S,T)return J{S,T;pkind=R,}end end end end do local o=i k['init']=function(...)local p,q,r=getmetatable,setmetatable,pcall local s=n"util"local t,u,v,w=s.copy,s.map,s.nop,s.unpack local x,y,z,A,B,C,D,E,F,G=w(u(n,{"API","charsets","compiler","constructors","datastructures","evaluator","factorizer","locale","printers","re"}))local H,I=r(n,"package")local J=s.noglobals()local K="0.12"local L="0.1.0"local function M(Q,R)q(R,{__index=Q})end local function N(Q,R)r(function()I.loaded.lpeg=Q I.loaded.re=Q.re end)if R then R.lpeg,R.re=Q,Q.re end return Q end local function O(Q)Q=Q and t(Q)or{}local R,S={options=Q,factorizer=D},{new=O,version=function()return K end,luversion=function()return L end,setmaxstack=v}S.util=s S.global=M S.register=N y(R,S)B(R,S)F(R,S)A(R,S)x(R,S)C(R,S);(Q.compiler or z)(R,S)E(R,S)S.re=G(R,S)return S end local P=O()return P end end do local o=i k['compat']=function(...)local p,q,r p,q=pcall(n,"debug")p,r=pcall(n,"jit")r=p and r local s={debug=q,lua51=(_VERSION=="Lua 5.1")and not r,lua52=_VERSION=="Lua 5.2",luajit=r and true or false,jit=r and r.status(),lua52_len=not#setmetatable({},{__len=function()end}),proxies=pcall(function()local t=newproxy(true)local u=newproxy(t)assert(type(getmetatable(t))=="table"and(getmetatable(t))==(getmetatable(u)))end),_goto=not not(loadstring or load)"::R::"}return s end end do local o=i k['optimizer']=function(...)end end return n"init"end)return a("__root")